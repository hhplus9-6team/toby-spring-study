# 3.6 스프링의 JdbcTemplate

> 앞서 템플릿/콜백의 기본적인 원리, 동작방식, 만드는 법을 알아보았고 이번 챕터에서는 스프링이 제공하는 템플릿/콜백 기술을 알아본다.
> JDBC 코드용 기본 템플릿은 **JdbcTemplate**이다. 앞에서 만들었던 JdbcContext와 유사하지만, 훨씬 강력하고 편리한 기능을 제공한다.

JdbcTemplate은 생성자의 파라미터로 DataSource를 주입하면 된다.

```java
public class UserDao {
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
}
```

## 3.6.1 update()

### deleteAll()에 적용

`StatementStrategy` 인터페이스의 `makePreparedStatement()` 메소드와 대응되는 JdbcTemplate의 콜백은 `PreparedStatementCreator` 인터페이스의 `createPreparedStatement()` 메소드다. 
템플릿으로부터 Connection을 제공받아서 PreparedStatement를 만들어 돌려준다는 면에서 구조는 동일하다.

JdbcTemplate의 템플릿 메소드 `update()` 메소드는 SQL 문장을 실행하는 템플릿으로, PreparedStatementCreator 콜백을 받아서 PreparedStatement를 만들고, 이를 실행해서 업데이트 작업을 수행한다.

```java
public void deleteAll() throws SQLException {
    this.jdbcTemplate.update(
        new PreparedStatementCreator() {
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                return con.prepareStatement("delete from users");
            }
        }
    );
}
```

JdbcTemplate에는 콜백을 받는 `update()` 메소드 외에도, **SQL 문장만 전달하면 되는** 내장 콜백을 사용하는 `update()` 메소드도 있다.
JdbcTemplate 내부에서 SQL 문자열을 받아 PreparedStatementCreator 콜백을 자동으로 만들어주기 때문에 코드가 훨씬 간결해진다.

```java
public void deleteAll() throws SQLException {
    this.jdbcTemplate.update("delete from users");
}
```

### add()에 적용

add() 메소드에서는 PreparedStatement를 만들고 함께 제공하는 파라미터를 순서대로 바인딩해주는 기능을 가진 `update()` 메소드를 사용할 수 있다. SQL과 함께 가변인자로 바인딩할 파라미터를 전달하면 된다.

```java
public void add(final User user) throws SQLException {
    this.jdbcTemplate.update("insert into users(id, name, password) values(?,?,?)",
        user.getId(), user.getName(), user.getPassword());
}
```

## 3.6.2 queryForInt()

### getCount()에 적용

`getCount()`는 SQL 쿼리를 실행하고 ResultSet을 통해 결과 값을 가져오는 코드다. 이런 작업 흐름을 가진 코드에서 사용할 수 있는 템플릿은 `PreparedStatementCreator` 콜백과 `ResultSetExtractor` 콜백을 파라미터로 받는 `query()` 메소드다.

```java
public int getCount() throws SQLException {
    return this.jdbcTemplate.query(
        new PreparedStatementCreator() {
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                return con.prepareStatement("select count(*) from users");
            }
        },
        new ResultSetExtractor<Integer>() {
            public Integer extractData(ResultSet rs) throws SQLException, DataAccessException {
                rs.next();
                return rs.getInt(1);
            }
        }
    );
}
```

`ResultSetExtractor`는 PreparedStatement의 쿼리를 실행해서 얻은 ResultSet을 전달받는 콜백이다. 템플릿이 이 콜백에게 ResultSet을 넘겨주고, 콜백이 여기서 추출한 결과를 템플릿에 리턴하면, 템플릿은 나머지 작업을 수행한 뒤에 그 결과를 `query()` 메소드의 리턴 값으로 돌려준다.

콜백이 2개가 나와서 복잡해보이지만,
- 첫번째 PreparedStatementCreator 콜백은 템플릿으로부터 Connection을 제공받아서 PreparedStatement를 만들어 돌려주는 역할을 한다. 
- 두번째 ResultSetExtractor 콜백은 템플릿이 쿼리를 실행해서 얻은 ResultSet을 전달받아서, 여기서 필요한 데이터를 추출해서 리턴하는 역할을 한다.

 
JdbcTemplate의 `queryForInt()` 메소드는 Integer 타입의 결과를 가져올 수 있는 SQL 쿼리를 실행해준다.
```java
public int getCount() throws SQLException {
    return this.jdbcTemplate.queryForInt("select count(*) from users");
}
```

> [!NOTE]
> JdbcTemplate은 이렇게 **스프링이 제공하는 클래스이지만 DI 컨테이너를 굳이 필요로 하지 않는다.** 직접 JdbcTemplate 오브젝트를 생성하고 필요한 DataSource를 전달해주기만 하면 된다.

## 3.6.3 queryForObject()

### get()에 적용

`get()` 메소드는 id를 가지고 하나의 User 오브젝트를 가져오는 것이다. SQL의 실행 결과가 로우 하나인 경우에 사용할 수 있는 `queryForObject()` 메소드를 사용한다.

이 메소드는 SQL에 바인딩이 필요한 치환자 `?`가 있으므로, 이를 `Object[]` 배열로 전달한다. 그리고 ResultSet의 로우를 하나의 오브젝트에 매핑해주는 `RowMapper` 콜백을 사용한다.

```java
public User get(String id) throws SQLException {
    return this.jdbcTemplate.queryForObject("select * from users where id = ?",
        new Object[] {id},
        new RowMapper<User>() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
                return user;
            }
        }
    );
}
```

`RowMapper`는 ResultSet의 로우 하나를 매핑하기 위해 사용되기 때문에 여러 번 호출될 수 있다. 반면 앞의 `ResultSetExtractor`는 ResultSet을 한 번 전달받아 알아서 추출 작업을 모두 진행하고 최종 결과만 리턴하는 것이다.

`queryForObject()`는 SQL을 실행해서 받은 로우의 개수가 하나가 아니라면 `EmptyResultDataAccessException` 예외를 던지도록 만들어져 있다. 따라서 기존에 직접 만들었던 예외 처리 코드를 대신해준다.

## 3.6.4 query()

### 기능정의와 테스트 작성

현재 등록되어 있는 모든 사용자 정보를 가져오는 `getAll()` 메소드를 추가한다. `getAll()` 메소드의 요구사항은 다음과 같다.

- 테이블의 모든 User 로우를 가져온다.
- 기본키인 id 순으로 정렬해서 가져온다.

기능을 구현하기 전에, 먼저 테스트를 작성한다. 사용자를 하나씩 추가하면서 매번 `getAll()`의 결과를 확인한다.

```java
public void getAll() throws SQLException {
    dao.deleteAll();

    dao.add(user1);
    List<User> users1 = dao.getAll();
    assertThat(users1.size(), is(1));
    checkSameUser(user1, users1.get(0));

    dao.add(user2);
    List<User> users2 = dao.getAll();
    assertThat(users2.size(), is(2));
    checkSameUser(user1, users2.get(0));
    checkSameUser(user2, users2.get(1));

    dao.add(user3);
    List<User> users3 = dao.getAll();
    assertThat(users3.size(), is(3));
    checkSameUser(user1, users3.get(0));
    checkSameUser(user2, users3.get(1));
    checkSameUser(user3, users3.get(2));
}
```

### query() 템플릿을 이용한 getAll() 구현

`query()` 메소드는 여러 개의 로우가 결과로 나오는 일반적인 경우에 쓸 수 있다. `query()`의 리턴 타입은 `List<T>`이며, `RowMapper` 콜백을 이용해 각 로우를 오브젝트에 매핑해준다.

```java
public List<User> getAll() {
    return this.jdbcTemplate.query("select * from users order by id",
        new RowMapper<User>() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
                return user;
            }
        }
    );
}
```

바인딩할 파라미터가 없으므로 두 번째 파라미터는 생략한다. `query()` 템플릿은 SQL을 실행해서 얻은 ResultSet의 모든 로우를 열람하면서 로우마다 `RowMapper` 콜백을 호출한다. 이미 매핑된 User 오브젝트는 자동으로 리스트에 추가되고, 작업이 끝나면 모든 로우에 대한 User 오브젝트를 담고 있는 `List<User>`가 리턴된다.

### 테스트 보완

`getAll()`에 대한 테스트에서는 결과가 없을 때의 동작도 검증해야 한다. `query()` 템플릿은 결과가 없는 경우에 `queryForObject()`처럼 예외를 던지지 않고, **크기가 0인 List<T> 오브젝트를 리턴**한다.

```java
dao.deleteAll();

List<User> users0 = dao.getAll();
assertThat(users0.size(), is(0)); // 데이터가 없을 때는 빈 리스트가 리턴됨
```

## 3.6.5 재사용 가능한 콜백의 분리

### DI를 위한 코드 정리

JdbcTemplate을 도입한 덕분에 UserDao에서 DataSource를 직접 사용할 필요가 없어졌다. 불필요한 인스턴스 변수는 제거하되, `setDataSource()` 메소드는 JdbcTemplate을 생성할 때 필요하므로 유지한다.

JdbcTemplate을 생성할 때 직접 DataSource를 DI 받아서 만들 수 있지만, JdbcTemplate을 아예 스프링 빈으로 등록하고 DI 받는 방법도 있다. JdbcTemplate은 멀티스레드 환경에서도 안전하게 공유할 수 있으므로 싱글톤 빈으로 등록해서 사용해도 된다.

### 중복 제거

`get()`과 `getAll()`에서 사용하는 RowMapper의 내용이 똑같다. User용 RowMapper 콜백을 **메소드에서 분리**해 중복을 제거하고 재사용할 수 있다. RowMapper를 인스턴스 변수로 선언하여 공유한다.

```java
public class UserDao {
    private JdbcTemplate jdbcTemplate;

    private RowMapper<User> userMapper =
        new RowMapper<User>() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
                return user;
            }
        };
```

이를 적용하면 `get()`과 `getAll()`은 아래와 같이 간결해진다.

```java
public User get(String id) {
    return this.jdbcTemplate.queryForObject("select * from users where id = ?",
        new Object[] {id}, this.userMapper);
}

public List<User> getAll() {
    return this.jdbcTemplate.query("select * from users order by id", this.userMapper);
}
```

### 템플릿/콜백 패턴과 UserDao

최종적으로 완성된 UserDao 코드는 다음과 같다. UserDao에는 User 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 깔끔하게 담겨 있다.

```java
public class UserDao {
    private JdbcTemplate jdbcTemplate;

    private RowMapper<User> userMapper =
        new RowMapper<User>() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
                return user;
            }
        };

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void add(final User user) {
        this.jdbcTemplate.update("insert into users(id, name, password) values(?,?,?)",
            user.getId(), user.getName(), user.getPassword());
    }

    public User get(String id) {
        return this.jdbcTemplate.queryForObject("select * from users where id = ?",
            new Object[] {id}, this.userMapper);
    }

    public void deleteAll() {
        this.jdbcTemplate.update("delete from users");
    }

    public int getCount() {
        return this.jdbcTemplate.queryForInt("select count(*) from users");
    }

    public List<User> getAll() {
        return this.jdbcTemplate.query("select * from users order by id", this.userMapper);
    }
}
```

UserDao에는 User 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 깔끔하게 담겨 있다.

JDBC API 사용 방식, 예외처리, 리소스 반납, 커넥션 가져오기 등에 대한 책임은 모두 JdbcTemplate에게 있다. 변경이 일어나더라도 UserDao 코드에는 아무런 영향을 주지 않는다. 그런 면에서 **책임이 다른 코드와는 낮은 결합도**를 유지하고 있다. 다만 JdbcTemplate이라는 템플릿 클래스를 직접 이용한다는 면에서 특정 템플릿/콜백 구현에 대한 강한 결합을 가지고 있다.

## 질문
- `ResultSetExtractor`와 `RowMapper`의 차이점은 무엇이며, 각각 어떤 경우에 사용하는 것이 적합한가?
- JdbcTemplate을 사용하면서도 특정 템플릿/콜백 구현에 대한 강한 결합이 남아있다는 것은 어떤 의미이며, 이를 해결할 방법이 있는가?
