# 3.4. 컨텍스트와 DI
## 1. JdbcContext의 분리
* 현재까지의 상황 정리
    * 클라이언트 - UserDao의 메소드
    * 개별 전략 - 익명 내부 클래스
    * 컨텍스트 - jdbcContextWithStatementStrategy() 메소드
* jdbcContextWithStatementStrategy() 는 다른 DAO 에서도 사용 가능하다.
* jdbcContextWithStatementStrategy() 를 UserDao에서 분리하면 다른 DAO도 쓸수 있다.
```java
public class JdbcContext {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;

        try {
            c = dataSource.getConnection();
            ps = stmt.makePreparedStatement(c);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try { ps.close(); } catch (SQLException e) { }
            }
            if (c != null) {
                try { c.close(); } catch (SQLException e) { }
            }
        }
    }
}
```
```java
public class UserDao {
    private JdbcContext jdbcContext;

    public void setJdbcContext(JdbcContext jdbcContext) {
        this.jdbcContext = jdbcContext;
    }

    public void add(final User user) throws SQLException {
        jdbcContext.workWithStatementStrategy(new StatementStrategy() {
           //생략
        });
    }
}
```
* 이전의 의존관계가 UserDao -> JdbcContext -> DataSource 였다면, 
* 이제는 UserDao -> JdbcContext 와 JdbcContext -> DataSource로 분리됨

## 2. JdbcContext의 특별한 DI
### JdbcContext을 DI할 때 인터페이스를 사용하지 않는 이유
* UserDao는 항상 JdbcContext 클래스와 함께 사용하는 긴밀한 관계이기 때문이다.
  * JDBC대신 ORM을 사용해야한다면 JdbcContext가 통째로 변경되어야 하며
  * 테스트조차 JDBC와 함께 사용해야한다.
* 이정도로 강한 결합성은 굳이 인터페이스를 두지 않고 DI하는 것을 정당화한다.
> 스프링이랑 같이 테스트하는 경우만 책이 고려하는 듯 해 보인다.

### Spring Bean으로 DI vs 코드로 수동 DI
#### Spring Bean으로 DI
* Spring Bean을 사용한 DI의 장점
  1. 싱글톤 패턴을 적용할 수 있다.
      * JdbcContext는 읽기 전용이므로 상태를 가지지 않기 때문에 싱글톤으로 만들어도 문제가 없다.
      * 또한 여러 DAO에서 공유해서 사용되는 오브젝트이므로 싱글톤으로 만들어 사용하는 것이 적절하다.
  2. JdbcContext가 DI 를 통해 다른 bean(DataSource)에 의존할 수 있다.
    * JdbcContext가 Bean이므로 DataSource도 Bean으로 등록되어 있다면 DI를 통해 DataSource를 주입받을 수 있다.
  3. 의존관계가 설정파일에 명확하게 드러난다.
* Spring Bean으로 DI하는 방식의 단점
  * UserDao와 JdbcContext가 긴밀한 관계이지만, 어색하게 빈으로 분리되어 있다.

#### 수동 DI
* 스프링 bean으로 DI하는 방식과 달리, UserDao 내부에서 직접 JdbcContext 객체를 생성해서 사용하는 방식
```java
public class UserDao {
    private JdbcContext jdbcContext;

    public void setDataSource(DataSource dataSource) {
        this.jdbcContext = new JdbcContext();
        this.jdbcContext.setDataSource(dataSource);
    }
    
    public void add(final User user) throws SQLException {
        jdbcContext.workWithStatementStrategy(new StatementStrategy() {
           //생략
        });
    }
} 
```
* 수동 DI 시 문제점
    1. 싱글톤으로 만들 수 없다.
        * UserDao에서 생성하는 방식이기 때문에 UserDao 갯수만큼 JdbcContext 객체가 만들어짐
        * 하지만 대형 프로젝트라도 수백개 이상은 만들어지지 않을 것이므로 용인될 만한 수준
        * 또한 빈번히 오브젝트가 만들어지고 제거되는 것도 아니니 GC에 무리 없음
    2. DataSource는 어떻게 DI 받나?
        * JdbcContext 자신이 Bean이 아니니 DataSource를 DI 받을 수 없음
        * 해결책: JdbcContext에 대한 제어권을 가지고 생성과 관리를 담당하는 UserDao에게 DI를 맞기는 것
    3. DI 작업을 위한 부가적인 코드가 필요하다.
* 수동 DI하는 방식의 장점
  * 굳이 인터페이스를 두지 않아도 될 만큼 긴밀한 관계인 DAO클래스와 JdbcContext를 
    어색하게 빈으로 분리하지 않고 내부에서 직접 만들어 사용하면서 다른 오브젝트에 대한 DI를 적용할 수 있기 때문

---
## QnA
* JdbcContext를 분리한 이유는 무엇이고, 인터페이스를 사용하지 않은 이유는 무엇인가요?