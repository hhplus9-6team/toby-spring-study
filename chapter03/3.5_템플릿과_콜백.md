# 3.5 템플릿과 콜백

## 1. 서론

지금까지 JDBC 코드의 중복과 예외 처리 문제를 해결하기 위해 전략 패턴을 적용했고, `jdbcContext`라는 공통 실행 구조를 만들었습니다.

> 공통 흐름은 그대로 두고,
> 변하는 로직만 더 간결하게 전달할 수 없을지?

에 대한 고민으로 나온 것이 **템플릿/콜백 패턴** 입니다.

## 2. 템플릿과 콜백

```java
public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = dataSource.getConnection();
        ps = stmt.makePreparedStatement(c);
        ps.executeUpdate();
    } finally {
        if (ps != null) ps.close();
        if (c != null) c.close();
    }
}
```

지금까지 만든 `jdbcContext`를 살펴보면, 이미 "변하는 것과 변하지 않는 것"을 분리한 상태입니다.

### 1) 템플릿이란?

- 공통 흐르을 고정해둔 구조
- 변하지 않는 알고리즘의 골격

```java
try {
    c = dataSource.getConnection();
    ps = stmt.makePreparedStatement(c);
    ps.executeUpdate();
} finally {
    ...
}
```

`jdbcContext`에서 템플릿이란 "커넥션 획득, 실행, 예외 처리, 리소스 반환" 에 해당됩니다.

### 2) 콜백이란?

- 템플릿이 실행 도중 호출하는 코드
- 변하는 부분

```java
stmt.makePreparedStatement(c);
```

`jdbcContext`에서 콜백이란 "`makePreparedStatement()` 내부의 SQL 작성" 에 해당됩니다.

## 3. 콜백의 분리와 재활용

```java
public void delete(final String id) throws SQLException {
    this.jdbcContext.workWithStatementStrategy(
            new StatementStrategy() {
                public PreparedStatement makePreparedStatement(Connection c)
                        throws SQLException {

                    PreparedStatement ps =
                            c.prepareStatement("delete from users where id = ?");
                    ps.setString(1, id);
                    return ps;
                }
            }
    );
}
```

`jdbcContext`를 사용할 때, 모든 SQL을 익명 내부 클래스로 작성하면 호출부가 길어질 수 있습니다.

SQL이 길어지거나 동일 로직이 반복되면 익명 클래스는 오히려 가독성을 해칠 수 있습니다.

이 때 콜백을 별도로 분리할 수 있습니다.

```java
public void executeSql(final String query) throws SQLException {
    this.jdbcContext.workWithStatementStrategy(
        new StatementStrategy() {
            public PreparedStatement makePreparedStatement(Connection c)
                    throws SQLException {
                return c.prepareStatement(query);
            }
        }
    );
}
```

```java
public void deleteAll() throws SQLException {
    executeSql("delete from users");
}
```

### 개선된 점

- 익명 내부 클래스 최소화
- 가독성 향상
- 전략 재사용 가능
- 테스트 용이성 증가

즉, 콜백은 인라인으로도 사용할 수 있지만, 필요하다면 분리해 재활용할 수도 있습니다.

이 유연함이 템츨릿/콜백의 강점입니다.

## 4. 전략 패턴과의 차이 

전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 이 방식을, 스프링에서는 템플릿/콜백 패턴이라고 부릅니다.

전략 패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부릅니다.

전략 패턴은 전략 객체를 미리 만들어 주입한다면, 템플릿/콜백은 전략을 실행 시점에 전달합니다.

- 전략 패턴 → 구조 중심
- 템플릿/콜백 → 실행 중심

즉, 전략 패턴을 실용적으로 발전시킨 형태가 템플릿/콜백입니다.

## 5. 응용: Calculator 예제

DAO/JDBC에서 했던 “공통 흐름(변하지 않는 것) vs 변화 로직(변하는 것)” 분리를, 토비는 더 단순한 예제인 Calculator(파일 읽기 계산기) 로 다시 연습시킵니다.

핵심은 동일합니다.

- 변하지 않는 것: 파일 열기/읽기/닫기, 예외 처리, 리소스 반환

- 변하는 것: 각 라인을 어떻게 누적할지(합/곱/문자열 연결 등)

### 1) 초기 구현

```java
public class Calculator {

    public int calcSum(String filePath) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(filePath));

        int sum = 0;
        String line;
        while ((line = br.readLine()) != null) {
            sum += Integer.parseInt(line);
        }

        br.close();
        return sum;
    }
}
```

#### 문제점 : 

- 예외가 중간에 터지면 `br.close()`가 실행되지 않을 수 있음
- “곱”, “최댓값”, “문자열 이어붙이기” 같은 계산이 추가되면 파일 읽기 코드가 그대로 중복됨

### 2) 테스트 + try/catch/finally

```java
public int calcSum(String filePath) throws IOException {
    BufferedReader br = null;
    try {
        br = new BufferedReader(new FileReader(filePath));

        int sum = 0;
        String line;
        while ((line = br.readLine()) != null) {
            sum += Integer.parseInt(line);
        }
        return sum;

    } finally {
        if (br != null) {
            try { br.close(); } catch (IOException e) { /* ignore */ }
        }
    }
}
```

- 유틸/인프라성 코드는 테스트로 감싸며 개선
- 예외가 어느 시점에 나든 finally는 실행되므로 `close`가 보장됨
- 이것으로 “안전성”은 확보

### 3) 중복 제거 + 템플릿/콜백 설계

```java
public int calcMultiply(String filePath) throws IOException {
    BufferedReader br = null;
    try {
        br = new BufferedReader(new FileReader(filePath));

        int multiply = 1;
        String line;
        while ((line = br.readLine()) != null) {
            multiply *= Integer.parseInt(line);
        }
        return multiply;

    } finally {
        if (br != null) try { br.close(); } catch (IOException e) {}
    }
}
```

“곱 계산”을 추가한다면, 파일 여는 코드부터 while까지 전부 똑같아집니다.

중복의 핵심:
- 파일 열기
- 한 줄씩 읽기
- close 보장

이 “고정된 흐름”을 템플릿으로 만들고, “줄을 어떻게 누적할지”를 콜백으로 뺄 수 있습니다.

#### 콜백 인터페이스

```java
public interface BufferedReaderCallback {
    Integer doSomethingWithReader(BufferedReader br) throws IOException;
}
```

#### 템플릿 메서드

```java
public Integer fileReadTemplate(String filePath, BufferedReaderCallback callback) throws IOException {
    BufferedReader br = null;
    try {
        br = new BufferedReader(new FileReader(filePath));
        return callback.doSomethingWithReader(br);
    } finally {
        if (br != null) try { br.close(); } catch (IOException e) {}
    }
}
```

#### 합계/곱을 콜백으로 구현

```java
public int calcSum(String filePath) throws IOException {
    return fileReadTemplate(filePath, br -> {
        int sum = 0;
        String line;
        while ((line = br.readLine()) != null) {
            sum += Integer.parseInt(line);
        }
        return sum;
    });
}

public int calcMultiply(String filePath) throws IOException {
    return fileReadTemplate(filePath, br -> {
        int multiply = 1;
        String line;
        while ((line = br.readLine()) != null) {
            multiply *= Integer.parseInt(line);
        }
        return multiply;
    });
}
```

- 파일 열기/닫기/예외 처리는 템플릿 1곳으로 고정
- 계산 로직은 콜백만 교체하면 됨 (확장 쉬움)

### 4) 템플릿/콜백의 재설계

지금 콜백은 BufferedReader 전체를 받습니다. 

그래서 합/곱 모두 콜백 내부에 while 루프가 그대로 중복됩니다.

즉, “변하지 않는 것”을 아직 덜 걷어낸 상태입니다.

- 진짜 변하지 않는 건: `while (readLine)` 루프

- 진짜 변하는 건: `line` 한 줄을 누적하는 규칙

따라서 콜백을 “라인 단위”로 더 잘게 쪼갤 수 있습니다.

#### 라인 콜백 인터페이스

```java
public interface LineCallback {
    Integer doSomethingWithLine(String line, Integer value);
}
```

#### 라인 기반 템플릿

```java
public Integer lineReadTemplate(String filePath, LineCallback callback, int initVal) throws IOException {
    BufferedReader br = null;
    try {
        br = new BufferedReader(new FileReader(filePath));

        Integer result = initVal;
        String line;
        while ((line = br.readLine()) != null) {
            result = callback.doSomethingWithLine(line, result);
        }
        return result;

    } finally {
        if (br != null) try { br.close(); } catch (IOException e) {}
    }
}
```

#### 합계/곱을 콜백으로 구현

```java
public int calcSum(String filePath) throws IOException {
    return lineReadTemplate(filePath,
        (line, value) -> value + Integer.parseInt(line),
        0
    );
}

public int calcMultiply(String filePath) throws IOException {
    return lineReadTemplate(filePath,
        (line, value) -> value * Integer.parseInt(line),
        1
    );
}
```

- while 루프 중복 제거 완료
- “변하는 로직”이 정말 최소 단위(한 줄 처리)로 내려옴
- 템플릿/콜백 설계가 더 “응집도 높게” 정리됨

### 5) 제네릭스를 이용한 콜백 인터페이스

지금까지는 반환/누적 타입이 Integer로 고정돼 있습니다. 

그런데 “라인을 이어 붙여 문자열을 만들기”, “객체로 누적하기” 같은 요구가 올 수도 있습니다.

그래서 콜백과 템플릿을 제네릭으로 일반화해봅니다.

#### 제네릭 콜백

```java
public interface LineCallback<T> {
    T doSomethingWithLine(String line, T value);
}
```

#### 제네릭 템플릿

```java
public <T> T lineReadTemplate(String filePath, LineCallback<T> callback, T initVal) throws IOException {
    BufferedReader br = null;
    try {
        br = new BufferedReader(new FileReader(filePath));

        T result = initVal;
        String line;
        while ((line = br.readLine()) != null) {
            result = callback.doSomethingWithLine(line, result);
        }
        return result;

    } finally {
        if (br != null) try { br.close(); } catch (IOException e) {}
    }
}
```

#### 기존 기능(합/곱)은 그대로 동작

```java
public int calcSum(String filePath) throws IOException {
    return lineReadTemplate(filePath,
        (line, value) -> value + Integer.parseInt(line),
        0
    );
}
```

#### 문자열 누적 같은 새로운 요구도 “콜백만” 추가하면 끝

```java
public String concatLines(String filePath) throws IOException {
    return lineReadTemplate(filePath,
        (line, value) -> value + line,
        ""
    );
}
```

## 6. 결론

1. 기본 구현: 기능은 되지만 예외/중복에 취약

2. try/finally: 리소스 반환 보장 (안정성)

3. 템플릿/콜백 도입: 공통 흐름과 변화 로직 분리 (확장성)

4. 재설계(라인 콜백): 변하는 것만 더 작게, 공통 흐름을 더 크게 (중복 제거 극대화)

5. 제네릭: 템플릿/콜백을 “타입까지” 재사용 가능하게 일반화 (범용성)


> 템플릿은 변하지 않는 흐름을 책임지고, 콜백은 변하는 로직만 제공한다.
> 
> 그리고 좋은 설계는 콜백을 더 작게 만들고(응집도↑), 템플릿을 더 재사용 가능하게 만든다(결합도↓).

---

### 질문

Q. 템플릿과 콜백을 한 문장으로 각각 정의해보세요.

- 템플릿이 책임지는 것은 무엇인가?

- 콜백이 책임지는 것은 무엇인가?

---

### 출처

- 토비의 스프링 3.1 - Vol.1 스프링의 이해와 원리