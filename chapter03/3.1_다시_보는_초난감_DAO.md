# 3.1 다시 보는 초난감 DAO

## 0. 서론

다시 한 번 초난감 DAO로 돌아와서, 단순한 중복 코드가 아니라 예외 상황에서의 안정성, 특히 리소스 반환 문제에 초점을 맞춰서 살펴보고자 합니다.

## 1. JDBC 수정 코드에서의 예외 발생 문제

```java
public void add(User user) throws SQLException {
    Connection c = dataSource.getConnection();
    PreparedStatement ps = c.prepareStatement(
        "insert into users(id, name, password) values(?,?,?)");

    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    ps.executeUpdate();

    ps.close();
    c.close();
}
```

다음과 같은 JDBC 수정 코드가 존재할 때,

겉보기에는 문제없어 보이지만 예외가 발생하는 순간 이 코드는 심각한 문제를 일으킬 수 있습니다.

- `Connection`

- `PreparedStatement`

JDBC 코드에서 사용하는 주요 리소스는 다음과 같습니다.

```java
ps.close();
c.close();
```

문제는 예외가 발생하면 위의 코드가 실행되지 않을 수 있다는 점입니다.

예를 들어:

- SQL 문법 오류

- 네트워크 장애

- DB 커넥션 문제

이 중 하나라도 발생하면 `close()`가 호출되지 않은 채 메서드가 종료될 수 있습니다.

### Connection의 역할

Connection은 단순한 객체가 아니라, 

**애플리케이션과 데이터베이스 사이의 물리적/논리적 연결을 대표하는 리소스**
입니다.

- DB와의 연결 유지

- 트랜잭션 경계 관리

- SQL 실행을 위한 통로 제공

```java
Connection c = dataSource.getConnection();
```

대부분의 서버 애플리케이션에서는 `DriverManager` 대신 `Connection Pool(DataSource)` 을 사용합니다.

- 실제 DB 커넥션은 미리 여러 개 생성됨
- `getConnection()` → 풀에서 하나를 빌려옴
- `close()` → 실제 종료 X → 풀로 반환

즉, `Connection`은 반드시 반환(close)되어야 하는 고가의 자원입니다.

### PreparedStatement의 역할

`PreparedStatement`는 **하나의 SQL 실행 작업을 캡슐화한 객체** 입니다.

- SQL 문장 준비
- 파라미터 바인딩
- SQL 실행 요청

```java
PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
```

- `PreparedStatement`는 `Connection`에 종속됨

- `Connection`이 살아 있어야만 동작 가능

- `Connection`이 닫히면 `PreparedStatement`도 의미를 잃음

- `PreparedStatement`를 닫아도 `Connection`은 여전히 유효

PreparedStatement는 Connection보다 가벼워 보이지만,

- DB 서버 측 리소스를 점유할 수 있고

- 내부적으로 Statement 캐시를 사용하기도 하며

- GC 대상이 되지 않는 네이티브 리소스를 포함할 수 있으므로

**PreparedStatement도 “반드시 반환해야 하는 자원”** 입니다.

### GC 가 안되는 이유

#### JVM 메모리

```
[Heap]
Connection 객체
 └─ nativeHandle (포인터)

[Native 영역]
 └─ JDBC 드라이버 네이티브 자원
     └─ 소켓 / OS 리소스

[DB Server]
 └─ DB 세션
```

Connection, PreparedStatement, ResultSet은 JVM 힙에 존재하는 자바 객체이지만,

실제로는 JVM 외부의 네이티브 자원과 DB 서버 리소스를 가리키는 핸들 객체에 가깝습니다.

GC는 힙 메모리만 관리할 뿐, DB 서버 자원까지 정리할 수 없기 때문에 반드시 명시적인 close가 필요합니다.

#### 핸들객체란

- 외부 자원을 직접 소유하지 않고, 그 자원을 가리키는 참조(포인터)만 가진 자바 객체를 의미
  - Connection → DB 서버 세션을 가리키는 핸들 
  - PreparedStatement → DB 실행 컨텍스트를 가리키는 핸들 
  - ResultSet → DB 커서를 가리키는 핸들

## 2. 리소스 반환 문제

대부분의 서버 애플리케이션은 커넥션 풀(Connection Pool) 을 사용하고 있습니다.

### 커넥션 풀의 기본 동작

- 커넥션은 새로 생성되지 않고 재사용

- close() 호출 시 실제 종료 X → 풀로 반환

### 문제 상황

- 예외로 인해 close()가 호출되지 않으면 커넥션이 풀로 반환되지 않음

- 결국 커넥션 고갈

- 서버 전체 장애로 이어질 수 있음

따라서 단일 DAO의 예외 처리 미흡이 서버 장애로 확장될 수 있습니다.

## 3. try / catch / finally로 리소스 반환 보장

```java
public void add(User user) throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = dataSource.getConnection();
        ps = c.prepareStatement(
            "insert into users(id, name, password) values(?,?,?)");

        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();
    } catch (SQLException e) {
        throw e;
    } finally {
        if (ps != null) {
            try { ps.close(); } catch (SQLException e) {}
        }
        if (c != null) {
            try { c.close(); } catch (SQLException e) {}
        }
    }
}
```

이를 해결하기 위해 예외 발생 여부와 상관없이 리소스를 반환해야 합니다.

- `finally` 블록은 예외 발생 여부와 관계없이 실행

- 생성에 성공한 리소스만 `close()`

- null 체크 필수

```java
public User get(String id) throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;
    ResultSet rs = null;

    try {
        c = dataSource.getConnection();
        ps = c.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        rs = ps.executeQuery();
        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        return user;
    } catch (SQLException e) {
        throw e;
    } finally {
        if (rs != null) {
            try { rs.close(); } catch (SQLException e) {}
        }
        if (ps != null) {
            try { ps.close(); } catch (SQLException e) {}
        }
        if (c != null) {
            try { c.close(); } catch (SQLException e) {}
        }
    }
}
```

조회 기능에서는 `ResultSet`이 추가되어 더욱 복잡해집니다.

`ResultSet`은 단순한 결과 객체가 아니라, **SQL 실행 결과를 한 줄씩 스트리밍 형태로 읽기 위한 커서** 입니다.

- DB 서버에 커서가 열리고
- JDBC 드라이버가 네트워크 버퍼 / 메모리 / 네이티브 리소스 점유

DB 서버와 JDBC 드라이버의 리소스를 점유하는 객체이기 때문에 반드시 `close()`를 해야 합니다.



리소스가 늘어날수록:

- 코드 길이 증가

- 실수 가능성 증가

- DAO 로직의 본질이 가려짐

### finally 동작에 대한 보충 설명

`finally`는 예외 처리 로직을 위한 문법이 아니라, “반드시 실행돼야 하는 코드”를 위한 문법입니다.

예외 발생 시점과 관계없이 실행 흐름이 `finally`를 거치도록 JVM이 보장하기 때문에, JDBC 리소스 반환과 같은 정리(clean-up) 작업에 가장 적합합니다.

`return` 이나 `throw` 이전에도 항상 호출된다.

```java
try {
    return 1;
} finally {
    System.out.println("finally");
}
```

실행결과:

```
finally
```

`return`도 제어 흐름 변경을 합니다.

JVM은 `finally`를 “탈출 직전 훅(hook)”처럼 동작하도록 합니다.
1. return 값 저장 
2. finally 실행 
3. return 수행

따라서, `finally`가 실행되지 않는 경우는 아래와 같은 경우 밖에 없습니다.

- System.exit()
- JVM 강제 종료 (SIGKILL)
- 하드웨어 오류

## 4. 결론

- 예외 발생 시에도 리소스 반환 보장

- 서버 환경에서도 안정적으로 동작

- DB 연결 방식(DataSource) 확장 가능

이제 DAO는 위와 같은 내용을 보장하며 “안전한 DAO”가 완성되었습니다.

하지만 여전히 문제가 있습니다.

- 모든 메서드에 반복되는 try/catch/finally

- 비즈니스 로직보다 예외 처리 코드가 더 많음

- DAO 본질(SQL 실행)이 가독성을 잃음

---

### 질문

Q. JDBC 코드에서 리소스를 반환하지 않으면 커넥션 풀 환경에서 어떤 문제가 발생할 수 있나요?

---

### 출처

- 토비의 스프링 3.1 - Vol.1 스프링의 이해와 원리