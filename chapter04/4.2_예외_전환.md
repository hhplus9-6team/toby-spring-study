# 4.2 예외 전환

예외를 다른 것으로 바꿔서 던지는 예외 전환의 목적은 아래와 같이 두 가지이다.

- 런타임 예외로 포장하여 굳이 필요하지 않은 try/catch/throws를 줄여준다.
- 로우 레벨의 예외를 좀 더 의미있고 추상화된 예외로 바꿔준다.

## 4.2.1 JDBC의 한계

JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API의 형태로 정의하고, 각 DB 업체는 JDBC 표준에 따라 만들어 진 드라이버를 제공한다.
개발자 입장에서는 표준화된 JDBC API의 사용법만 습득하면 이론상 DB 밴더에 상관 없이 프로그램을 개발할 수 있다.
하지만 실제 상황에서 DB를 자유롭게 바꾸어 사용하는 것이 쉬운 일은 아니다.

### 비표준 SQL

모든 DB 밴더사에서 사용할 수 있는 표준 SQL이 정의되어있으나, 실제로는 각 밴더에 특화된 비표준 SQL을 사용해야 하는 경우가 빈번하다.
해당 DB에 특화된 기능을 사용하거나, DB에 최적화된 SQL을 작성해야 할 경우가 그렇다.
페이징 쿼리를 작성해야 할 때, Oracle과 MySQL 쿼리의 차이를 보면 쉽게 이해할 수 있다.

### 호환성 없는 SQLException의 DB 에러 정보

DB를 사용하다가 발생하는 에러의 원인은 다양하다. 또한 DB 밴더 별 에러의 종류와 원인도 제각각이기 때문에,
JDBC는 데이터 처리 중 발생하는 다양한 예외를 SQLException 계열에 담아 처리한다.
호환성 없는 에러코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException만으로 DB에 독립적인 유연한 코드를 작성하는건 불가능하다.

## 4.2.2 DB 에러 코드 매핑을 통한 전환

DB 업체별로 만들어서 유지하고있는 DB 전용 에러 코드를 사용하여 발생한 예외의 원인이 무엇인지 해석할 수 있도록 매핑 정보를 명시할 수 있다.

```xml
<bean id="Oracle" class="org.springframework.jdbc.support.SQLErrorCodes">
 <property name="badSqlGrammerCodes">
  <value>900,903</value>
 </property>
    ...
</bean>
```

위와 같이 특정 DB 업체의 에러 코드를 매핑 정보로 담아두면 JdbcTemplate 사용 시 발생한 SQLException의 에러 코드를 매핑 정보와 비교하여
적절한 형태의 예외로 포장해줄 수 있다.

## 4.2.3 DAO 인터페이스와 DataAccessException 계층 구조

### DAO 인터페이스와 구현의 분리

DAO 계층을 따로 만들어서 사용하는 이유는 데이터 액세스 로직을 담은 코드를 성격이 다른 코드(비지니스 로직)에서 분리해놓기 위해서이다.
DAO를 사용하는 쪽에서는 DAO가 내부에서 어떤 데이터 액세스 기술을 사용하는지 신경쓰지 않아야한다.
-> DAO를 기존과 같은 방식이 아닌 인터페이스를 사용하여 구체적인 클래스 정보와 구현 방법을 감추고 DI를 활용하는 것이 더 바람직하다.

하지만 DAO를 인터페이스로 분리한다면, 메소드 선언의 예외 정보가 문제가 될 수 있다.

```java
public interface UserDao {
 public void add(User user); //JDBC API를 사용하여 add()를 구현할 때 throws SQLException이 필요하다.
 //...
}
```

이를 위해 `public void add(User user) throw SQLException;` 형태로 변경하였더라도, 만약 JDBC가 아닌 다른 데이터 엑세스 기술로 변경해야할 경우
interface의 구현체를 작성할 수 없게 된다.
문제를 해결하기 위해 `throw Exception`과 같이 수정하거나 구현체에서 발생하는 예외를 try/catch로 처리해줄 수도있다.
하지만 인터페이스를 추상화하고 일부 기술에서 발생하는 체크 예외를 런타임 예외로 전환하는 방식은 불출분한 방식이다.

### 데이터 액세스 예외 추상화와 DataAccessExcepion 계층 구조

스프링은 자바의 다양한 데이터 액세스 기술을 사용할 때 발생할 수있는 예외들을 `DataAccessExcepion` 계층 구조 안에 정리해놓았다.
데이터 액세스 기술에 상관없이 공통적인 예외도 있지만 JPA, 하이버네이트 등 특정 ORM에서는 발생하지만 JDBC에는 없는 예외도 있다.
`DataAccessExcepion`는 데이터 액세스 기술에서 발생 가능한 대부분의 예외를 계층구조로 분류해놓았다.

```bash
java.lang.RuntimeException
 └─ org.springframework.core.NestedRuntimeException
     └─ org.springframework.dao.DataAccessException
         ├─ NonTransientDataAccessException
         │   ├─ DataIntegrityViolationException
         │   │   └─ DuplicateKeyException
         │   ├─ DataRetrievalFailureException
         │   │   └─ IncorrectResultSizeDataAccessException
         │   │       └─ EmptyResultDataAccessException
         │   ├─ InvalidDataAccessApiUsageException
         │   ├─ InvalidDataAccessResourceUsageException
         │   │   ├─ IncorrectUpdateSemanticsDataAccessException
         │   │   └─ TypeMismatchDataAccessException
         │   ├─ NonTransientDataAccessResourceException
         │   │   └─ DataAccessResourceFailureException
         │   ├─ PermissionDeniedDataAccessException
         │   ├─ UncategorizedDataAccessException
         │   └─ CleanupFailureDataAccessException
         │       (deprecated)
         │
         ├─ TransientDataAccessException
         │   ├─ ConcurrencyFailureException
         │   │   ├─ OptimisticLockingFailureException
         │   │   └─ PessimisticLockingFailureException
         │   │       ├─ CannotAcquireLockException
         │   │       ├─ CannotSerializeTransactionException
         │   │       └─ DeadlockLoserDataAccessException
         │   └─ QueryTimeoutException
         │
         └─ RecoverableDataAccessException
```

인터페이스 사용, 런타임 예외 전환과 함께 DataAccessException 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수 있다.

## 4.2.4 기술에 독립적인 UserDao 만들기

### 인터페이스 적용

지금까지 써왔던 UserDao 클래스를 인터페이스와 구현으로 분리해보자.

```java
public interface UserDao {
 void add(User user);
 User get(String id);
 //...
}
```

구현체를 생성할 때는 `public class UserDaoJdbc implements UserDao {}` 와 같은 형식으로 class를 구현할 수 있다.
스프링 설정 파일을 사용할 경우 아래와 같이 UserDao가 UserDaoJdbc class를 사용하도록 바꿔주어야한다.

```xml
<bean id="userDao" class="spring.dao.UserDaoJdbc">
 <property name="dataSource" ref="dataSource" />
</bean>
```

### 테스트 보완

기존 UserDaoTest 클래스에서는 UserDao의 구현체를 사용하고있었으나, 인터페이스로 변경이 되었다.

```java
public class UserDaoTest {
 @Autowired
 private UserDao userDao; //이 부분을 인터페이스가 아닌 UserDaoJDBC 구현체로 변경해야할까?
}
```

하지만 구현체를 명시하지 않아도 Spring에 명시된 인터페이스 구현체 정보를 활용하여 자동으로 구현체를 주입해주기 때문에 해당 부분을 수정하지 않아도 테스트가 통과한다.
`duplicationKey()` 테스트 코드에 `@Test(expected=DataAccessException.claa)`를 추가로 명시해주면 중복 id로 인하여 발생하는 예외가 `DataAccessException` 혹은 서브 클래스임을 테스트 통과로 확인할 수도 있다.

### DataAccessException 활용 주의사항

예외 전환은 체크 예외를 런타임 예외로 바꿔 불필요한 try/catch를 줄이고, 저수준 기술 예외를 더 의미 있는 예외로 추상화하기 위한 것으로, 특히 JDBC는 DB 벤더마다 비표준 SQL과 호환되지 않는 에러 코드·상태 코드를 사용하므로 SQLException만으로는 기술 독립적인 DAO를 만들기 어렵다.
이를 해결하기 위해 스프링은 DB별 에러 코드를 매핑해 SQLException을 DataAccessException 계층으로 변환하고, DAO를 인터페이스로 분리해 구현 기술이 JDBC에서 JPA 등으로 바뀌더라도 사용부가 기술에 종속되지 않도록 돕는다. 다만 DataAccessException은 스프링이 변환한 데이터 접근 예외를 공통적으로 다루기 위한 것이지 모든 예외를 대표하는 것은 아니므로, 예외를 무조건 뭉뚱그려 처리하기보다는 하위 예외의 의미를 구분하고 필요 이상으로 예외를 삼키지 않도록 주의해야 한다.

---

### 질문

- JDBC의 SQLException만으로는 기술에 독립적인 DAO를 만들기 어려운 이유는 무엇이며, 스프링의 DataAccessException은 이 문제를 어떻게 해결하나요?
