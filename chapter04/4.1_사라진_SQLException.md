# 사라진 SQLException

앞서 JdbcContext를 JdbcTemplate로 변경하며 메소드 시그니처의 `throws SQLException`을 제거하였다.

## 4.1.1 초난감 예외처리

### 예외 블랙홀

```java
try {

} catch (Exception t) {} // 예외가 발생하는 코드에서 try catch로 예외를 잡지만 정작 catch 블럭에서는 아무 처리도 하지 않음
```

위와 같은 형태의 예외를 처리하지 않는 try/catch 블럭을 작성하는 개발자들이 종종 있다.
이러한 예외 처리 코드는 프로그램 실행 중 어디선가 오류가 있어 예외가 발생하였는데, 이를 무시하고 진행하기 때문에
발생한 예외로 인해 기능이 비정상적으로 동작하거나, 최종적 오작동을 하거나, 더 큰 문제를 발생시킬 수 있다.
가장 큰 문제는 시스템에서 발생한 오류의 원인을 찾아내기 매우 힘들다는 것.

> 예외를 처리할 때 반드시 지켜야 할 핵심 원칙은
> 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.
> -> `예외가 발생한 기능이 최종적으로 데이터 조작을 수행하면 안됨.`

SQLException은 SQL 문법에 오류가 있거나, DB에서 처리할 수 없을 정도로 데이터 엑세스에 버그가 있거나, 서버가 죽거나, 네트워크 연결이 불가능 하는 등 심각한 상황이 벌어졌음을
알려주는 예외이다. 이러한 예외를 아무 처리 없이 방치하는 것은 시스템에 큰 위험이 될 수 있다.

### 무의미하고 무책임한 throws

```java
public void method() throws Exception {
 method2()
 //...
}
public void method2() throws Exception {
 method3()
 //...
}
public void method3() throws Exception {
 //...
}
```

메소드 시그니처에 `throws Exception`을 명시하면 메소드 실행 중 발생하는 모든 예외에 대한 처리를 메소드 호출부로 전가시킬 수 있다. 하지만 반복적인 `throws Exception`의 작성은
예외 처리의 책임을 전가만 할 뿐 최종적으로 예외 발생의 처리를 수행하지 않게될 수도있다.

앞서 알아본 두 가지 (예외 블랙홀, 무책임 throws)는 절대로 용납해서는 안되는 코드이다.

## 4.1.2 예외의 종류와 특징

자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지이다.

### Error

java.lang.Error 클래스의 서브 클래스이다.
에러는 시스템에 비정상적인 상황이 발생하였을 경우 사용된다. 주로 자바 VM에서 발생시키는 것으로 애플리케이션 코드에서 잡을 수 없다.

- OutOfMemoryError, ThreadDeath 등

### Exception과 체크 예외

java.lang.Exception 클래스와 그의 서브 클래스이다.
에러와는 다르게 개발자들이 만든 애플리케이션 코드의 작업 중에 예외 상황이 발생했을 경우 사용된다.
Exception 클래스는 다시 `unchecked exception`과 `checked exception`으로 구분된다.

### RuntimeException과 언체크/런타임 예외

java.lang.RuntimeException 클래스를 상속한 예외들이다.
명시적인 예외 처리를 강제하지 않기 때문에 언체크 예외라한다.
런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다.

## 4.1.3 예외 처리 방법

### 예외 복구

예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려 놓는 것
발생한 예외를 처리하여 사용자로 하여금 다른 작업 흐름을 제공하거나, 실패한 작업에 대해 재시도 처리를 통해 예외 상황을 복구하기 위한 시도를 할 수 있다.

### 예외 처리 회피

예외 처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
JdbcTemplate의 콜백 메서드는 작업하다 발생하는 예외를 직접 처리하지 않고 throw 형태로 메소드 호출부로 던져주도록 작성되어있다.

```java

	@Override
	public void execute(final String sql) throws DataAccessException {
		if (logger.isDebugEnabled()) {
			logger.debug("Executing SQL statement [" + sql + "]");
		}

		// Callback to execute the statement.
		class ExecuteStatementCallback implements StatementCallback<Object>, SqlProvider {
			@Override
			@Nullable
			public Object doInStatement(Statement stmt) throws SQLException {
				stmt.execute(sql);
				return null;
			}
			@Override
			public String getSql() {
				return sql;
			}
		}

		execute(new ExecuteStatementCallback(), true);
	}
```

발생한 예외를 처리하는 작업이 콜백 오브젝틔 역할이 아니라고 보기 때문

### 예외 전환

예외를 복구하여 정상적인 상태로 만들 수 없는 경우 예외를 적절한 예외로 전환하여 호출부로 던지는 것
SQLException과 같이 범용으로 사용되는 예외를 좀 더 의미가 분명한 예외로 한 번 더 감싸 던지면, 서비스 게층에서는
던져진 예외의 종류에 따라 적절한 복구 작업을 시도할 수 있다.

## 4.1.4 예외처리 전략

### 런타임 예외의 보편화

일반적으로 체크 예외가 일반적인 예외(IOException, SQLException)를 다루고, 언체크 예외(NullPointerException, IllegalArgumentException)는 시스템 장애나 프로그램상의 오류에 사용한다.
자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고 있다.

### add() 메소드의 예외처리

SQLException은 대부분 복구가 불가능한 예외이므로 잡아봤자 처리할 것도 없고, 결국 throws를 타고 계속 호출부로 전달될 것이다.
SQLException이 발생한 상황이 중복된 ID 값으로 인하여 발생하였을 경우 DuplicatedUserIdException과 같이 Custom RuntimeException을 정의하여
호출부에서 적절한 복구 처리를 할 수 있도록 만들 수 있다.

### 애플리케이션 예외

체크 예외가 처리되지 않을 경우 예외 처리를 강제하도록 컴파일 타임에 개발자에게 인지시킨다. 만약 계좌 잔고 처리와 같이 정합성이 중요하고 위험도가 높은 작업의 경우
의도적으로 체크 예외를 만들어 개발자가 잊지 않고 해당 예외에 대한 처리를 로직으로 강제하도록 하는것이 좋다.

---

## 질문

- checked Exception과 unchecked Exception의 차이는 무엇인가?
- 대표적인 checked Exception과 unchecked Exception은 무엇이 있나?
