# 1.1 초난감 DAO

> [!NOTE]
> #### DAO(Data Access Object)
> - **실제 데이터베이스나 파일 같은 영구 저장소에 접근하는 객체**를 의미한다.
> - 데이터베이스 연결, SQL 쿼리 실행, 결과 처리 등의 작업을 수행한다.
>
> DTO(Data Transfer Object) -> DAO와 혼동 주의!
> - **계층 간에 데이터를 전달하는 객체**를 의미한다.
> - 로직 없이 순수하게 데이터만 담는 컨테이너 역할을 한다.

## 1.1.1 User

#### User 클래스
```java
public class User {
    private String id;
    private String name;
    private String password;
    // getter, setter 생략
}
```

## 1.1.2 UserDao

### JDBC를 이용하는 작업의 일반적인 순서
1. DB 연결을 위한 Connection 객체를 생성한다
2. SQL 실행을 위한 PreparedStatement 객체를 생성한다
3. SQL을 실행한다 (삽입/수정/삭제는 executeUpdate, 조회는 executeQuery)
4. 결과를 처리한다 (삽입/수정/삭제는 영향받은 행의 수, 조회는 ResultSet)
5. 사용한 자원을 해제한다 (Connection, PreparedStatement, ResultSet)
6. 예외를 처리한다 

#### 예제) 사용자(User)를 데이터베이스에 추가하고 조회하는 DAO 클래스
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.ResultSet;

public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection(
            "jdbc:mysql://localhost/springbook", "spring", "book"
        );

        PreparedStatement ps = c.prepareStatement(
            "INSERT INTO users(id, name, password) VALUES(?, ?, ?)"
        );
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection(
            "jdbc:mysql://localhost/springbook", "spring", "book"
        );

        PreparedStatement ps = c.prepareStatement(
            "SELECT * FROM users WHERE id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

## 1.1.3 main()을 이용한 DAO 테스트 코드
코드 기능을 검증할 때 가장 간단한 방법은 객체 스스로 검증하도록 만들어 주는것 = main() 메서드

```java
public class UserDaoTest {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        UserDao userDao = new UserDao();

        User user = new User();
        user.setId("leevigong");
        user.setName("리비공");
        user.setPassword("password1234");

        userDao.add(user);
        System.out.println("등록 성공");

        User user2 = userDao.get("leevigong");
        System.out.println("조회 성공");

        if (!user.getName().equals(user2.getName())) {
            System.out.println("테스트 실패 (name)");
        } else if (!user.getPassword().equals(user2.getPassword())) {
            System.out.println("테스트 실패 (password)");
        } else {
            System.out.println("조회된 사용자 정보 일치");
        }
    }
}
```

<details>
<summary>왜 초난감 DAO일까?</summary>

- UserDao 클래스가 너무 많은 책임을 가지고 있다
- UserDao 클래스가 너무 구체적인 기술(JDBC API)에 의존하고 있다
- UserDao 클래스가 확장에 취약하다 (예: 다른 DBMS로 변경 시)
- UserDao 클래스가 재사용에 취약하다 (예: 다른 애플리케이션에서 사용 시)
- UserDao 클래스가 테스트에 취약하다 (예: DB 연결 실패 시)
- UserDao 클래스가 유지보수에 취약하다 (예: SQL 문 변경 시)
- UserDao 클래스가 가독성에 취약하다 (예: 코드가 길고 복잡함)
- UserDao 클래스가 성능에 취약하다 (예: 매번 새로운 Connection 생성)
- UserDao 클래스가 보안에 취약하다 (예: SQL 인젝션 공격)
- UserDao 클래스가 트랜잭션 관리에 취약하다 (예: 여러 작업의 원자성 보장 어려움)
- UserDao 클래스가 예외 처리에 취약하다 (예: SQLException 직접 노출)
- UserDao 클래스가 확장성에 취약하다 (예: 새로운 기능 추가 어려움)
- UserDao 클래스가 의존성 주입에 취약하다 (예: 외부 설정 어려움)
- ...
</details>


## 질문
- DAO의 역할은 무엇인가?

