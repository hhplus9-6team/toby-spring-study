# 2.4. 스프링 테스트 적용
## 1. Spring과 Junit
### 1.1. 아무 조치 없이 Spring과 Junit을 함께 사용할 때 문제점
* ApplicationContext는 초기화하는데 시간이 많이 걸리기에
  테스트 메서드가 실행될 때마다 ApplicationContext를 생성하면 비효율적이다.
* ApplicationContext는 초기화될 때 빈들을 생성하는데,
  특정한 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 쓰레드를 띄우기도 하여
  리소스 정리를 깔끔하게 하지 않으면 오류가 발생할 수 있다.

---
### 1.2. Spring과 Junit을 함께 사용하기 위한 조치
ApplicationContext를 static 필드로 둠으로써 해결한다.
```java
@RunWith(SpringJUnitClassRunner.class) // 스프링의 테스트 컨텍스트 프레임워크의 Junit 확장기능 지정
@ContextConfiguration(locations="/applicationContext.xml") // 테스트 컨텍스트의 설정 정보 지정
public class UserDaoTest {
    @Autowired
    private ApplicationContext context; // 스프링 테스트 컨텍스트 주입
    
    //생략
}
```
#### 1) 코드 설명
* `@RunWith(SpringJUnitClassRunner.class)`
    * JUnit 프레임워크의 테스트 실행방법을 확장할 때 사용하는 애너테이션
    * `Runner`을 상속한 클래스를 매개변수로 받으며 run 메서드를 실행하는 역할을 가진 것으로 보인다.
* `SpringJUnitClassRunner.class`
    * JUnit용 테스트 컨텍스트 프레임워크 확장 클래스
    * DI 제어권을 가진 테스트용 ApplicationContext를 생성하는 책임을 가진 클래스
* `@ContextConfiguration`
    * 자동 생성되는 ApplicationContext 설정 파일 위치 지정하는 애너테이션
* `@Autowired`
    * 스프링의 `ApplicationContext`는 초기화할 때 자신도 빈으로 등록해두기에 Spring을 통한 DI가 가능하다

#### 2) 개선 사항
* "같은 설정파일"을 가진 테스트 클래스와 메서드는 모두 하나의 ApplicationContext를 공유한다.
* 따라서 초기화 시간이 줄어들어 빠르고 간결한 테스트를 진행할 수 있다.

---
## 2. 테스트에서의 DI 이용
### 2.1. 테스트에서도 느슨한 관계가 중요한 이유
* 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.
* 클래스 구현 방식이 바뀌지 않아도 인터페이스를 두고 DI를 적용하면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.
* 코드가 특정(=운영) 환경이나 기술에 종속되지 않도록 하기 때문이다.

---
### 2.2. 테스트 DI활용 예시
> 테스트는 Spring 없이 POJO로만 진행하는 것을 우선하는 편을 권장
#### 1) ApplicationContext 운영/개발 환경 분리
* 개발용 설정정보 파일을 둔 뒤 `@ContextConfiguration`에 개발 설정파일 지정

#### 2) 컨테이너 없이 빈객체를 POJO로 대체
* 테스트 실행할 때 스프링 없이 직접 `new`키워드로 빈객체를 생성해서 주입하기
* 장점: 기술에 의존없이 자신의 관심에만 집중해서 만들 수 있다.

---
## 3. JUnit4과 Junit5(Jupiter)
### 3.1. 구조의 차이
| JUnit4 | 하나의 jar파일에 번들로 포함                                         |
|--------|-----------------------------------------------------------|
| JUnit5 | Junit Platform, Junit Jupiter, JUnit Vintage의 하위 프로젝트로 구성 |

---
### 3.2. 어노테이션의 차이
| JUnit 4      | 	JUnit 5     | 	설명                           |
|--------------|--------------|-------------------------------|
| @Test        | 	@Test       | 	테스트 메소드 선언                   |                    
| @BeforeClass | 	@BeforeAll  | 	현재 클래스의 모든 테스트 메서드보다 먼저 실행   |    
| @AfterClass  | 	@AfterAll   | 	현재 클래스의 모든 테스트 메서드 실행 후 실행   |
| @Before      | 	@BeforeEach | 	각 테스트 메서드 전에 실행              |
| @After       | 	@AfterEach  | 	각 테스트 메서드 후에 실행              |
| @Ignore      | 	@Disabled   | 	테스트 메서드/클래스 비활성화             |
| NA	          | @TestFactory | 	동적 테스트를 위한 테스트 팩토리           |
| NA	          | @Nested      | 	중첩 테스트                       |
| @Category    | 	@Tag        | 	태깅(Tagging) 및 필터링(Filtering) |
| @RunWith	    | @ExtendWith  | 	사용자 정의 확장 등록               | 

---
### 3.3. `@ContextConfiguration` vs `@SpringApplicaitonCongifguation`vs `@SpringBootTest`
> 책임소지만 파악하려고 한거라 정확한 비유/설명은 아님.

| |        | 
|-|--------------------------------------------------------------------------------------|
|`@ContextConfiguration`| Spring에서 동작하기에 Boot의 추가 속성을 로드하지 않음 <br/> Spring, SpringBoot 둘 다 사용 가능|
|`@SpringApplicaitonCongifguation`| SpringBoot 로깅을 활성화하고 application.yml파일에 정의된 추가 속성까지 로드(SpringBoot 1.4 미만)            |
|`@SpringBootTest`| `@ExtendWith` + `@SpringApplicationConfiguration`. |

---
## 4. Jupiter 과 AssertJ
### 4.1. 둘의 차이점
* Jupiter : JUnit5에 속하는 프레임워크 구성 중 하나.
* AssertJ : 테스트의 "검증"부분을 더 강력하고 표현력있게 만드는 **도구**

---
## 5. 테스트에 자주 사용하는 Annotation
### 5.1. `@Import`
* Spring에서 동작하는 어노테이션. `org.springframework.context.annotation`에 속한다.
* ApplicationContext에 설정을 추가로 합쳐 넣는 책임을 가진다.
* 사용 경우:
    * `@SpringBootTest`처럼 “풀 컨텍스트”가 부담스럽거나,
    * `기본 로딩 대상이 아닌 빈을 추가로 넣고 싶을 때
* `@ContextConfiguration`과의 차이 :
    * `@ContextConfiguration`은 "컨텍스트를 어떤 구성으로 만들지"를 지정하는 느낌
    * `@Import`는 "이미 정해진 컨텍스트 구성에 추가로 끼워넣기" 느낌

---
### 5.2. `@WebMvcTest`
* 주로 Controller를 단위테스트할 때 사용
* 로드 범위: @Controller, @ControllerAdvice, WebMvcConfigurer, HandlerMethodArgumentResolver, Converter, Filter 등 MVC 관련 빈 중심
* 일반적으로 Service/Repository 같은 빈은 로딩하지 않음
    * 그래서 컨트롤러가 의존하는 서비스가 있으면 보통 @MockBean으로 대체해서 주입

---
### 5.3. `@SpringBootTest + @AutoConfigureMockMvc`
* (대개 @SpringBootTest와 함께) ‘전체 컨텍스트’를 띄운 뒤 MockMvc도 같이 세팅해주는 옵션
* 로드 범위: 애플리케이션 전체 빈(거의 실환경에 가까움)
    * 서비스/레포지토리/DB 설정/보안 설정 등까지 함께 올라올 수 있음
* 목적: MockMvc로 요청을 보내되, 내부는 거의 실제 구성으로 동작하는 통합 테스트에 가까운 웹 테스트

---
## QnA
1. 테스트에서 구현체가 아닌 인터페이스를 사용하여 DI를 이용하는경우 얻는 장점 기술하기