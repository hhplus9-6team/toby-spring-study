# 1.2. DAO의 분리

## 1. 개선이 필요한 DAO
```java
public class UserDao {
    // JDBC API가 만들어내는 Exception을 메서드 밖으로 던진다
    public User get(String id) throws ClassNotFoundException, SQLException {
        // DB 연결을 위한 Connection 가져오기
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook", "spring", "book");
        
        // SQL을 담은 Statement를 만든다
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        // 만들어진 Statement를 실행한다
        ResultSet rs = ps.executeQuery();
        rs.next();
        // SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
        User user = new User();
        user.setId(rs.getString("id"));
        
        // 작업중에 생성된 Connection, Statement, ResultSet 같은 리소스를 닫아준다.
        rs.close();
        ps.close();
        c.close();
        
        return user;
    }
}
```
### UserDao 클래스의 관심사
1) DB 연결을 위한 커넥션을 가져오는 것
2) DB로 보낼 SQL 문장에 파라미터를 바인딩시키고, 실행하는 것
3) 작업이 끝나면 리소스 오브젝트를 닫는 것

---
## 2. 이미 충실하게 기능을 수행 중인 코드를 개선해야하는 이유는 무엇인가?
> * 이 DAO는 기대한 기능을 충실히 수행한다. 그럼에도 **이 코드를 수정하고 개선해야하는 이유는 무엇인가?**
    >   * 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 무엇인가?
>   * DAO 코드를 개선했을 때의 장점은 무엇인가?
>   * 이런 장점이 당장에, 미래에 주는 유익은 무엇인가?
>   * 객체지향 설계의 원칙과는 무슨 상관이 있을까?
>   * DAO를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서 무슨 차이가 있을까?
>
> > 책 읽기 전 나의 포괄적인 답변:
> > 새로운 기능을 추가하거나 기존 기능에 수정이 필요할 때 복잡한 코드 탓에 개발 공수가 많이 들고, 유지보수에 좋지 않다.

### 오브젝트에 대한 설계와 이를 구현한 코드는 계속 변한다
* 사용자 비즈니스 프로세스와 요구사항은 끊임없이 변함
* 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 변함
* 운영되는 환경도 변함

### 객체지향 프로그래밍은 변화에 변화의 폭을 최소한을 줄이는 것이 목적이다
* 객체지향 설계와 프로그래밍은 절차적 프로그래밍 패러다임에 비해 초기에 더 번거로운 작업을 요구하지만,
  변화에 효과적으로 대처할 수 있다는 기술적인 특징을 가지고 있다.
* 객체지향 프로그래밍은 실세계를 최대한 가깝게 모델링 할 수 있어서 의미 있는 것이 아니다.
* 객체지향 기술이 만들어내는 가상의 추상세계를 효과적으로 구성하고, **자유롭고 편리하게 변경, 확장 시킬수 있다는 것에 의미**가 있다.

### 변화의 폭을 최소한으로 줄이는 것: 관심사의 분리와 확장
> 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
* 분리: 한 곳에 모여있는 다양한 관심사 → 한 곳에 하나의 관심사만 있도록 집중시키는 것
* 확장: // TODO

---

## 3. 첫번째 관심사 리팩토링 : DB 연결을 위한 커넥션을 가져오는 것
### 개선해야하는 이유
* Connection 가져오는 코드가 다른 관심사와 섞여있고
* DB 커넥션에 대한 정보가 모든 메서드에 하나씩 존재해서 DB 연결에 대한 정보가 변경되면 모든 메서드를 수정해야함

### 첫 번쨰 개선: 메서드 추출로 변경점 한 곳으로 집중
```java
public class UserDao{
    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        // 생략
    }
    public Connection getConnection() throws ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook", "spring", "book");
    }
}
```

---
### 두 번째 개선: 사용하는 Connection 객체가 달라질 경우 대비해 팩토리 메서드 패턴 사용
```java
public abstract class UserDao{
    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        // 생략
    }
    // 서브 클래스에서 구현
    public abstract Connection getConnection() throws ClassNotFoundException;
```
#### 이 방법의 단점: 상속을 사용함
* 이미 상속관계가 존재하는 클래스면 사용 불가능
* 상하위 클래스의 관계가 너무 밀접해짐

---

## QnA
* 이미 제 기능을 하고 있는 코드를 리팩토링해야하는 이유에 대해 본인만의 답 적어보기