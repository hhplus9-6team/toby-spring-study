# 1.4 제어의 역전(IoC)

## 1.4.1 오브젝트 팩토리

UserDaoTest 클래스는 UserDao의 기능이 잘 동작하는지 테스트하기 위해 작성한 클래스지만,
ConnectionMaker의 구현 클래스를 결정하는 책임이 섞여있다.

```java
public class UserDaoTest {
	public static void main(String[] args) throws ... {
		ConnectionMaker connectionMaker = new DConnectionMaker(); // ConnectionMaker의 구현체를 결정

		UserDao dao = new UserDao(connectionMaker); // DConnectionMaker 구현체 주입

		//...
	}
}
```

### 팩토리

객체의 생성 방법을 결정하고 만들어진 오브젝트를 반환하는 클래스(DaoFactory)를 추가한다.

```java
public class DaoFactory {
	public UserDao userDao() {
		// UserDao 타입의 오브젝트를 어떻게 생성하고 준비시킬 지 결정
		ConnectionMaker connectionMaker = new DConnectionMaker();
		UserDao userDao = new UserDao(connectionMaker);
		return userDao;
	}
}
```

변경된 UserDaoTest는 UserDao 객체의 생성에 신경쓰지 않고 팩토리로부터 UserDao 오브젝트를 받아온다.

```java
public class UserDaoTest {
	public static void main(String[] args) throws ... {
		UserDao userDao = new DaoFactory().userDao();

		//...
	}
}
```

### 설계도로서의 팩토리

- **UserDao, ConnectionMaker** : 애플리케이션의 **핵심적인 데이터 로직과 기술 로직**을 담당
- **DaoFactory** : 애플리케이션의 **오브젝트를 구성하고 그 관계를 정의**하는 책임

## 1.4.2 오브젝트 팩토리의 활용

DaoFactory에 UserDao가 아닌 다른 DAO(AccountDao, MessageDao)의 생성 기능이 추가된 상황

```java
public class DaoFactory {
	public UserDao userDao() {
		return new UserDao(new DConnectionMaker());
	}

	public AccountDao accountDao() {
		return new AccountDao(new DConnectionMaker());
	}

	public MessageDao messageDao() {
		return new MessageDao(new DConnectionMaker());
	}
}
```

new DConnectionMaker()로 **ConnectionMaker 구현체를 생성하는 코드가 반복적으로 등장**
--> 중복 문제를 해결하기 위해 ConnectionMaker의 구현체를 결정하고 오브젝트를 만드는 코드를 **별도 메소드로 분리**

```java
public class DaoFactory {
	public UserDao userDao() {
		return new UserDao(getConnection());
	}

	public AccountDao accountDao() {
		return new AccountDao(getConnection());
	}

	public MessageDao messageDao() {
		return new MessageDao(getConnection());
	}

	private ConnectionMaker getConnection() {
		return new DConnectionMaker();
	}
}
```

: ConnectionMaker의 구현체가 변경되었을 때, 모든 Dao 생성 메소드를 수정하지 않고 getConnection() 한 군데만 수정하여 모든 팩토리 메소드에 적용할 수 있음

## 1.4.3 제어권의 이전을 통한 제어관계 역전

일반적인 프로그램은 아래와 같은 흐름으로 동작한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조

1. 프로그램이 시작되는 지점에 사용할 오브젝트를 결정
2. 결정한 오브젝트를 생성
3. 만들어진 오브젝트에 있는 메소드 호출
4. 반복

```java
public class BeforeIoCExample {

    public static void main(String[] args) throws Exception {
        UserDao userDao = new UserDao(); // ✅ UserDao가 내부에서 구현체를 고정/생성
        userDao.add("jw", "종완");
    }

    static class UserDao {
        // ❌ 제어권이 UserDao에 있음: 어떤 DB 연결 전략을 쓸지 UserDao가 결정하고 직접 생성
        private final ConnectionMaker connectionMaker = new DConnectionMaker();

        public void add(String id, String name) throws SQLException {
            try (Connection con = connectionMaker.makeConnection();
                 PreparedStatement ps = con.prepareStatement(
                         "INSERT INTO users(id, name) VALUES(?, ?)")) {
                ps.setString(1, id);
                ps.setString(2, name);
                ps.executeUpdate();
            }
        }
    }

    interface ConnectionMaker {
        Connection makeConnection() throws SQLException;
    }

    static class DConnectionMaker implements ConnectionMaker {
        @Override
        public Connection makeConnection() throws SQLException {
            // ... 구체적인 Connection 생성 구현 메소드
        }
    }
}
```

제어의 역전이란 프로그램의 제어 흐름 구조가 뒤바뀌는 것. 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.
템플릿 메소드 패턴 또한 제어의 역전 개념을 활용하여 문제를 해결하는 디자인 패턴의 종류

```java
public class ImprovedUserDaoExample {

    public static void main(String[] args) throws Exception {
        // ✅ 오브젝트 조립 책임(제어권)을 main -> DaoFactory로 위임
        DaoFactory factory = new DaoFactory();

        UserDao userDao = factory.userDao();

        userDao.add(new User("jw", "종완"));
        User user = userDao.get("jw");

        System.out.println("loaded: " + user);
    }

    /* =========================
       IoC 적용: 조립 전담 Factory
       ========================= */
    static class DaoFactory {

        public UserDao userDao() {
            // ✅ UserDao는 구현 선택을 하지 않음. 외부에서 주입해줌.
            return new UserDao(connectionMaker());
        }

        private ConnectionMaker connectionMaker() {
            // 여기서 구현체를 교체하면 UserDao 코드는 안 건드려도 됨
            return new DConnectionMaker();
            // return new NConnectionMaker();
        }
    }

    /* =========================
       DAO
       ========================= */
    static class UserDao {
        private final ConnectionMaker connectionMaker;

        // ✅ 의존성 주입(DI). UserDao는 "연결을 어떻게 만드는지" 모름.
        public UserDao(ConnectionMaker connectionMaker) {
            this.connectionMaker = connectionMaker;
        }

        public void add(User user) throws SQLException {
			//..
        }

        public User get(String id) throws SQLException {
			//..
        }
    }

    /* =========================
       Connection 전략(확장 포인트)
       ========================= */
    interface ConnectionMaker {
        Connection makeConnection() throws SQLException;
    }

    static class DConnectionMaker implements ConnectionMaker {
        @Override
        public Connection makeConnection() throws SQLException {
            // 예시용. 실제로는 환경변수/설정파일/커넥션풀(DataSource)로 분리
            return DriverManager.getConnection(
				//..
            );
        }
    }

    static class NConnectionMaker implements ConnectionMaker {
        @Override
        public Connection makeConnection() throws SQLException {
            return DriverManager.getConnection(
				//..
            );
        }
    }
}
```

---

### 라이브러리와 프레임워크의 차이점 (제어의 역전 관점)

#### 라이브러리: “내 코드가 주도, 필요할 때 호출”

- **제어권이 내 코드(애플리케이션) 쪽**에 있어.
- 실행 흐름(언제/어떤 순서로/어떤 조건에서 호출할지)을 **내가 결정**하고,
- 라이브러리는 그저 **도구 함수/객체**처럼 “호출되기만” 해.

#### 프레임워크: “프레임워크가 주도, 내 코드를 끼워 넣음”

- **제어권이 프레임워크(컨테이너/런타임) 쪽**으로 넘어가.
- 전체 실행 흐름(생명주기, 초기화, 요청 처리, 트랜잭션 시작/종료 등)을 프레임워크가 관리하고,
- 나는 특정 지점에 **규칙에 맞게 코드를 제공(등록/구현/어노테이션)** 해서 프레임워크가 “필요할 때 내 코드를 호출”하게 만든다.
- 즉, “내가 프레임워크를 부르는” 게 아니라 **프레임워크가 나를 부르는** 구조가 된다. 이게 IoC의 전형.

---

## 질문

1. UserDaoTest에서 ConnectionMaker 구현체를 직접 결정하던 책임을 DaoFactory로 분리했을 때, 테스트 코드/DAO 코드 관점에서 각각 무슨 이점이 생기는지

2. “제어의 역전”을 DaoFactory 예시와 연결해서,
   - 제어권이 어디에서 어디로 이동했는지
   - 그 결과 UserDao가 무엇을 몰라도 되게 되었는지(DI 효과)
