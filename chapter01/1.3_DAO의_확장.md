# 1.3 DAO의 확장

## 1) 서론

1.2 에서는 DB 연결이라는 관심사를 분리하는 과정에서 자연스럽게 상속 구조와 추상 메서드가 도입되었습니다.

UserDao는 추상 클래스로 바뀌고, DB 연결 방식은 하위 클래스에서 구현하도록 설계됩니다.

1.3은 이 구조를 바탕으로, "이 설계가 무엇을 해결했고, 어떤 한계를 가지는지"를 객체지향 설계 관점에서 정리하는 장입니다.


## 2) 1.2에서의 출발점: 상속을 이용한 관심사 분리

```java
public abstract class UserDao {

    public void add(User user) throws Exception {
        Connection c = getConnection();
        // JDBC 로직
    }

    public User get(String id) throws Exception {
        Connection c = getConnection();
        // JDBC 로직
    }

    protected abstract Connection getConnection() throws Exception;
}
```

```java
public class NUserDao extends UserDao {
    protected Connection getConnection() throws Exception {
        // N사 DB 연결
    }
}
```

```java
public class DUserDao extends UserDao {
    protected Connection getConnection() throws Exception {
        // D사 DB 연결
    }
}
```

- UserDao의 핵심 로직 (`add`, `get`)은 상위 클래스에 모입니다.
- DB 연결 방식이라는 변화 요소는 하위 클래스에서만 다룹니다.
- DB 환경이 달라져도 UserDao 자체는 수정하지 않습니다.

이에 따라 DAO는 수정이 아니라 확장으로 변화에 대응할 수 있게 됩니다.


## 3) 상속 기반 분리의 문제점

### (1) DAO 타입이 DB 연결 방식에 의해 결정된다

```java
UserDao dao = new NUserDao();
```

UserDao를 사용하려면 DB 연결 방식에 따라 DAO 구현 클래스를 선택해야 합니다.

즉, 사용자 데이터를 사용하고 싶어서 DAO를 쓰는데 DB 연결 방식이라는 세부 구현 때문에 DAO 타입이 달라집니다.


### (2) 확장 포인트가 DAO 자체로 굳어버린다

DB 연결 방식이 늘어날수록 UserDao 하위 클래스도 함께 늘어납니다.

DAO의 역할과 DB 연결 역할이 타입 구조에서 강하게 엮이게 됩니다.


### (3) 유연한 조합이 어렵다

상속 구조는 컴파일 타임에 관계가 고정됩니다.

테스트 환경이나 실행 환경에 따라 DB 연결 방식을 쉽게 바꾸거나 조합하기 어렵습니다.


## 4) 1.3에서의 개선: 상속이 아닌 협력 객체

DB 연결 방식은 UserDao의 "종류"가 아니라 UserDao가 사용하는 역할이라는 것입니다.

그래서 DB 연결 책임을 UserDao의 하위 클래스가 아닌 별도의 협력 객체로 분리합니다.

### (1) ConnectionMaker 도입

```java
public interface ConnectionMaker {
    Connection makeConnection() throws Exception;
}
```

```java
public class NConnectionMaker implements ConnectionMaker {
    public Connection makeConnection() throws Exception {
        // N사 DB 연결
    }
}
```

```java
public class DConnectionMaker implements ConnectionMaker {
    public Connection makeConnection() throws Exception {
        // D사 DB 연결
    }
}
```

```java
public class UserDao {

    private ConnectionMaker connectionMaker;

    public UserDao() {
        this.connectionMaker = new NConnectionMaker(); // 여기!
    }

    public void add(User user) throws Exception {
        Connection c = connectionMaker.makeConnection();
        // 사용자 추가 로직
    }
}

```

- UserDao는 하나의 클래스만 유지됩니다.
- DB 연결 방식은 독립적인 객체로 교체 가능합니다.
- DAO 선택과 DB 연결 선택이 분리됩니다.

이 개선으로 UserDao는 상속 구조 없이도 DB 연결 로직을 별도 클래스로 분리할 수 있었고,
`makeConnection()`이라는 역할에만 의존하게 되었습니다.

하지만 여전히 UserDao 내부에서 구체 구현체를 직접 생성하고 있기 때문에,
DB 연결 방식을 변경하려면 UserDao 코드를 수정해야 하는 한계는 남아 있습니다.


### (2) 의존성 생성 책임을 클라이언트로 이동시킨다

```java
public class UserDao {

    private final ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public void add(User user) throws Exception {
        Connection c = connectionMaker.makeConnection();
        // 사용자 추가 로직
    }
}
```

```java
ConnectionMaker cm = new NConnectionMaker();
UserDao dao = new UserDao(cm);
```

- UserDao의 책임: 사용자 데이터 접근 로직
- ConnectionMaker의 책임: DB 연결 생성
- 클라이언트의 책임: 어떤 구현을 조합할지 결정


## 5) 원칙/패턴 개념 정리

### (1) 높은 응집도 / 낮은 결합도

- 응집도: 한 클래스가 자기 책임에 얼마나 집중하는가

  → UserDao가 “DB 연결 생성”까지 하던 시점보다, “사용자 로직”에만 집중할수록 응집도가 높아짐.

- 결합도: 다른 요소 변화에 얼마나 쉽게 영향을 받는가

  → new NConnectionMaker()가 UserDao 안에 있으면 결합도가 높다.

  → ConnectionMaker(인터페이스)에만 의존하면 결합도가 낮아진다.


### (2) SRP (단일 책임 원칙)

- UserDao가 “사용자 CRUD” + “DB 연결 생성”을 같이 가지면 책임이 섞임.
- ConnectionMaker로 DB 연결 생성 책임을 분리하면 UserDao는 본래 책임에 집중.

### (3) OCP (개방-폐쇄 원칙)

- “DB 연결 방식 변경”이라는 확장 요구가 생겨도 UserDao 코드는 바뀌지 않아야 한다.
- 내부에서 new로 만들면 변경 시 UserDao 수정이 필요함(폐쇄 실패).
- 외부에서 주입하면 UserDao 수정 없이 구현체 교체로 확장 가능(개방).

### (4) DIP (의존 역전 원칙)

- UserDao가 NConnectionMaker 같은 구체에 의존하면 DIP 위반.
- UserDao가 ConnectionMaker라는 추상화에 의존하면 DIP 충족.
- “추상화에 의존하고, 구체는 밖에서 선택한다”가 핵심.

### (5) 전략 패턴(Strategy)

- DB 연결 방식은 상황(환경/고객사)에 따라 바뀌는 “행위/알고리즘”이다.
- ConnectionMaker 구현체가 “전략”이고, UserDao는 그 전략을 사용하는 “컨텍스트”가 된다.
- 전략을 바꿔 끼우듯이 구현체를 교체할 수 있다.



---

### 질문

Q. UserDao가 ConnectionMaker를 생성자에서 주입받도록 바꾸면서 각 객체의 책임은 어떻게 나뉘게 되었나요?

- UserDao : 
- ConnectionMaker :
- 클라이언트 :

---

### 출처 

- 토비의 스프링 3.1 - Vol.1 스프링의 이해와 원리