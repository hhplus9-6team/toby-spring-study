# 1.7 의존관계 주입(DI)

> 1.4 까지는 자바 코드만으로 객체지향 설계를 연습하며 응집도를 높이고 결합도를 낮추는 과정을 거치고, 
> 
> 1.5 ~ 1.6 에서는 그 설계를 스프링이 어떻게 대신 관리해주는지를 살펴봅니다.
> 
> 그리고 1.7에서는 우리가 직접 만든 구조를 스프링의 관점에서 다시 정리하며, 그 핵심 개념으로 의존관계 주입(DI) 을 소개합니다.
> 
> DI는 객체가 협력 대상을 직접 선택하지 않게 함으로써, 변경과 테스트에 강한 구조를 만드는 설계 기법입니다.


## 1.7.1 제어의 역전(IoC)과 의존관계 주입

```java
public class UserDao {
    private ConnectionMaker connectionMaker = new NConnectionMaker();
}
```

초기 UserDao는 스스로 의존 객체를 생성했습니다.

이 구조에서는

- UserDao가 어떤 구현체를 쓸지 직접 결정하고

- 객체 생성과 사용을 모두 책임졌습니다.

```java
public class DaoFactory {

    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }

    public ConnectionMaker connectionMaker() {
        return new NConnectionMaker();
    }
}
```

하지만 DaoFactory를 도입한 이후 구조는 달라졌습니다.

UserDao는 더 이상

- 객체를 생성하지 않고

- 의존관계를 결정하지 않습니다.

객체 생성과 의존관계 설정이라는 제어권이 UserDao에서 외부 구성 요소(DaoFactory)로 넘어갔습니다.

이처럼 객체가 스스로 제어하지 않고, 외부에서 제어받는 구조를 **제어의 역전(IoC)** 이라고 설명합니다.

**의존관계 주입(DI)** 은 이러한 IoC를 **의존관계 설정 관점에서 구체화한 설계 기법**입니다.

즉,
- IoC = 개념 
- DI = 구현 방식

## 1.7.2 런타임 의존관계 설정

DI의 중요한 특징 중 하나는 **의존관계가 런타임에 결정된다**는 점입니다.

```java
public class UserDao {

    private final ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }
}
```
```java
UserDao dao = new UserDao(new NConnectionMaker());
```

UserDao의 코드만 보면 어떤 DB 연결 구현체를 사용하는지 알 수 없습니다.

실제 의존관계는 객체를 생성하는 시점에 결정됩니다.

이 구조 덕분에

- 동일한 UserDao 코드로

- 개발/운영/테스트 환경에 따라

- 서로 다른 구현체를 사용할 수 있습니다

즉, **코드 수정 없이 조합만 바꿔서** 동작을 변경할 수 있습니다.

## 1.7.3 의존관계 검색과 주입

의존관계를 얻는 방식은 DI만 있는 것은 아닙니다.

객체가 직접 외부 환경에 요청해서 의존 객체를 가져오는 방식도 있습니다.

이를 **의존관계 검색(Dependency Lookup, DL)** 이라고 한다.

```java
ConnectionMaker cm = applicationContext.getBean("connectionMaker", ConnectionMaker.class);
```

의존관계 검색(DL) 방식의 특징은

- 객체가 컨테이너 API를 알아야 하고

- 스스로 의존관계를 요청한다는 점입니다

반면 의존관계 주입(DI) 방식에서는

- 객체는 컨테이너를 전혀 알 필요가 없고

- 의존관계는 외부에서 주입됩니다

## 1.7.4 의존관계 주입의 응용

```java
public class OrderService {
    private final MessageSender messageSender;

    public OrderService(MessageSender messageSender) {
        this.messageSender = messageSender;
    }
}
```

```java
OrderService service = new OrderService(new EmailMessageSender());
```

```java
OrderService service = new OrderService(new SmsMessageSender());
```

의존관계 주입은 DB 연결 같은 인프라 코드에만 적용되는 개념이 아닙니다.

변경 가능성이 있는 것이라면 무엇이든 DI의 대상이 될 수 있습니다.

정책이나 전략을 코드에 박아두지 않고, 외부에서 주입받도록 만들면 코드는 그대로 두고 정책만 교체할 수 있습니다.

예를 들어 다음과 같은 것들이 있습니다.

- 로깅 방식

- 트랜잭션 처리 전략

- 캐시 적용 여부

- 메시지 전송 방식


## 1.7.5 메소드를 이용한 의존관계 주입

```java
public class UserDao {

    private ConnectionMaker connectionMaker;

    public void setConnectionMaker(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }
}
```

의존관계 주입은 반드시 생성자를 통해서만 이루어지는 것은 아닙니다.

메소드 주입 방식은

- 생성 시점에 모든 의존성이 준비되지 않아도 되고

- 선택적인 의존관계를 주입할 수 있다는 장점이 있습니다

하지만 객체가 완전히 초기화되기 전에 사용될 위험이 있기 때문에 필수 의존관계에는 생성자 주입이 더 안전합니다.

---

### 질문

Q. 의존관계 주입(DI)과 의존관계 검색(DL)의 가장 큰 차이는 무엇인가요?

Q. 생성자 주입과 메소드 주입의 차이를 설명해보세요.

---

### 출처

- 토비의 스프링 3.1 - Vol.1 스프링의 이해와 원리