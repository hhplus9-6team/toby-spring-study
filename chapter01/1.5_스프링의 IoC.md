# 1.5. 스프링의 IoC
## 1. IoC 관점에서의 스프링
### 1.1. 용어 정리
> bean factory  = application context = container
* **빈(Bean)**
  * 스프링이 IoC 방식으로 관리하는 오브젝트
  * 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트 중
    스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다

* **빈 팩토리(Bean Factory)**
  * 빈을 등록/생성/조회/반환 등을 관리하는 기능을 담당하는 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다.
  * 보통 빈 팩토리를 바로 사용하는 것이 아닌 이를 확장한 애플리케이션 컨텍스트를 이용한다.

* **애플리케이션 컨텍스트(application context)**
  * 빈 팩토리를 확장(상속)한 IoC 컨테이너.
  * 빈 팩토리의 기능에서 스프링이 제공하는 각종 부가서비스를 추가로 제공한다.
  * 빈을 관리하기 위한 청사진(=메타정보)을 **실행**하는 오브젝트. 청사진은 외부에서 제공받는다.
  * application context는 인터페이스로 존재하고 이를 상속한 구현체들이 여럿 존재한다.

* **설정정보/설정 메타정보(configuration metadata)**
  * 애플리케이션 컨텍스트 혹은 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
  * 빈 오브젝트를 생성하고 구성할 때 사용된다.

* **컨테이너/IoC 컨테이너(container)**
  * application context와 bean factory를 부르는 또다른 용어
  * 컨테이너라는 말 자체가 IoC 개념을 담고 있다.
    * "container"은 **담고/관리하는 그릇/환경**을 가리킬 때 사용하는 용어

---
### 1.2. application context의 동작방식
`AnnotationConfigApplicationContext`/`singleton` 스코프의 경우
1. `@Configuration`이 붙은 설정메타정보를 등록
2. 설정 메타정보를 해석해서 빈 정의(BeanDefinition)들을 등록
3. Client가 application context의 getBean()을 호출하면 빈 목록에서 요청한 이름 검색
4. 이미 생성돼 있으면 캐시에서 반환하고, 없으면 정의를 바탕으로 생성해서 반환
   * singleton 스코프라면 context를 만들고 초기화하는 단계에 미리 싱글톤 빈들 생성
   * `@Lazy`가 붙거나, `prototype` 스코프 빈이면 `getBean()`이 실행되는 단계에 생성해서 반환

---
### 1.3. Spring이 자바레벨에서 관계를 관리하는 것(DaoFactory)보다 나은 이유
#### 애플리케이션 컨텍스트는 클라이언트가 구체적인 팩토리 클래스를 알 필요가 없다.
* as-is: 
  * 클라이언트가 어떤 팩토리 클래스를 사용할 건지 알아야함
  * 팩토리 클래스에 매번 오브젝트를 직접 추가해야함
* to-be:
  * 클라이언트는 팩토리 클래스를 알 필요가 없음-메타정보만 설정해서 Application Context에 설정해주면 애플리케이션 모든 내부에서 적용되기 때문
  * 후에 나오지만 `Annotation`을 이용해서 직접 추가하지 않을 수 있음 

#### 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공한다.
* as-is:
    * 실행하는 시점에 오브젝트를 생성 및 전략이 동일함
* to-be:
    * 빈 생성 방식/시점/전략을 다양하게 가져갈 수 있고
    * 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정방식 다변화 등 여러 기능 제공

#### 애플리케이션 컨텍스트는 Bean을 검색하는 다양하나 방법을 제공한다.
* as-is:
    * 미리 지정된 태그만으로 빈을 찾을 수 있다
* to-be:
    * 인터페이스/구현체 이름/타입 등 다양한 방식 빈을 찾을 수 있다.

---
## 2. Spring을 사용한 DAO 클래스 리팩토링
### 1) `DaoFactory`를 Application Context의 설정메타정보로 변경
```java
@Configuration // application context 또는 Bean Factory가 사용하는 설정정보라는 표시
public class DaoFactory {
    @Bean // Bean 생성을 담당하는 IoC용 메서드라는 표시 
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }

    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}
```
* `DaoFactory`는 "애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의"에 대한 정보이기에
* 생성된 빈의 이름은 `@Bean`이 붙은 **메서드의 이름**과 동일하게 생성된다.
  * 동일한 타입의 오브젝트가 Bean으로 생성될 수 있기 때문

---
### 2) 메타정보를 사용하여 IoC를 구성해줄 Application Context 생성
```java
public class UserDaoTest {
    public static void main(String[] args) throws Exception {
        ApplicationContext context = 
                new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao = context.getBean("userDao", UserDao.class);
        // 생략
    }
}
```
* ApplicationContext를 구현한 클래스는 여러가지 존재한다
* `@Configuration`이 붙은 자바 코드를 설정정보를 사용한다면 `AnnotationConfigApplicationContext`를 사용한다.

---
## QnA
* `ApplicationContext`와 `@Configuration`의 역할이 무엇이고 어떤 관계인가요?
* Object간의 관계를 자바코드로 직접 관리하는 것과 비교했을 때 Spring을 사용하는 것의 장점이 무엇인가요?
