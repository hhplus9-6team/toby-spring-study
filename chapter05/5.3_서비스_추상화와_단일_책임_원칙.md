# 5.3 서비스 추상화와 단일 책임 원칙

## 1. 왜 서비스 추상화가 필요한가

지금까지 JDBC, 트랜잭션 등 특정 기술에 종속되지 않도록 “서비스 추상화”를 도입했습다.

```java
txManager.begin();
try {
    userDao.save(user);
    txManager.commit();
} catch (Exception e) {
    txManager.rollback();
}
```

이 코드가 서비스 클래스 안에 그대로 들어 있다면, 비즈니스 로직은 트랜잭션 기술과 강하게 결합됩니다.

문제는 거기서 끝나지 않습니다.

- 트랜잭션 기술이 바뀌면?
- JDBC → JPA로 바뀌면?
- 로컬 트랜잭션 → JTA로 바뀌면?

서비스 로직이 함께 수정됩니다.

즉, 

> 기술 변경이 곧 비즈니스 로직 변경으로 이어지게 됩니다.

이것이 바로 책임이 섞인 상태입니다.

## 2. 수직·수평 계층 구조와 의존관계

스프링 애플리케이션은 기본적으로 계층 구조를 가집니다.

계층 구조의 목적은 단순한 정리가 아니라, 책임을 분리하기 위한 구조입니다.

### 1) 수직 구조

```
Controller
   ↓
Service
   ↓
Repository
   ↓
DB
```

각 계층은 서로 다른 책임을 가집니다.

- Controller → 요청 처리
- Service → 비즈니스 정책
- Repository → 데이터 접근

### 2) 수평 구조

같은 계층 안에서도 도메인별로 책임이 나뉩니다.

- UserService
- OrderService
- PaymentService

각 클래스는 하나의 도메인 책임을 가집니다.

## 3. 단일 책임 원칙 (SRP)

> 단일 책임 원칙 (SRP) 란 하나의 클래스는 하나의 책임만 가져야 한다는 의미입니다.

하지만 여기서 말하는 책임은 “기능 하나”가 아니라 “변경의 이유” 입니다.

즉, 한 클래스가 두 가지 이유로 수정될 수 있다면 그것은 두 개의 책임을 가진 것입니다.

### 예시: 책임이 섞인 클래스

```java
public class UserService {

    public void join(User user) {
        // 회원 가입 로직
        sendWelcomeEmail(user);
    }

    private void sendWelcomeEmail(User user) {
        // 이메일 전송 로직
    }
}
```

문제:
- 회원 정책이 바뀌면 수정
- 이메일 정책이 바뀌어도 수정

→ 변경 이유가 두 개

### 개선

```java
public class UserService {
    private final EmailSender emailSender;

    public void join(User user) {
        // 회원 가입 로직
        emailSender.send(user);
    }
}
```

```java
public class EmailSender {
    public void send(User user) {
        // 이메일 전송 로직
    }
}
```

- 회원 정책 변경 → UserService 수정
- 이메일 정책 변경 → EmailSender 수정

각각 하나의 책임만 가집니다.

## 4. 서비스 추상화와 SRP의 연결

서비스 추상화의 목적은 기술 세부 사항을 비즈니스 로직에서 분리하는 것입니다.

예를 들어 트랜잭션을 추상화하지 않으면:

- 트랜잭션 정책 변경
- 트랜잭션 기술 변경
- DB 기술 변경

이 모두가 서비스 클래스 변경으로 이어지게 됩니다.

이는 SRP 위반입니다.

하지만 트랜잭션을 추상화하면:

```java
@Transactional
public void join(User user) {
    userDao.save(user);
}
```

서비스는 “회원 가입 정책”에만 책임을 가지게 됩니다.

- 트랜잭션 기술 변경 → 플랫폼 계층 수정
- DB 접근 방식 변경 → Repository 수정
- 회원 정책 변경 → Service 수정

변경 이유가 분리됩니다.

## 5. 단일 책임 원칙의 장점

### 1) 변경 영향 최소화

책임이 분리되면:
- 변경 범위가 작음
- 다른 계층에 영향이 적음

### 2) 테스트 용이성 증가

Service가 기술에 의존하지 않으면:
- Mock 사용 가능
- 단위 테스트 가능
- 인프라 없이 테스트 가능

### 3) 확장성과 유연성 확보

- JDBC → JPA
- Local TX → JTA
- MailSender 변경

기술 교체가 가능해지고, 비즈니스 코드는 그대로 유지됩니다.

## 6. 결론

> 서비스 추상화는 기술 세부 사항을 분리함으로써 단일 책임 원칙을 지키게 만들고, 
> 이를 통해 계층 구조의 안정성과 변경에 강한 설계를 가능하게 합니다.

서비스 추상화는 단일 책임 원칙을 지키기 위한 도구로,

- 계층 구조는 책임을 수직으로 나누고
- 인터페이스는 책임 경계를 명확히 하며
- DI는 그 분리를 유지하게 만돕니다.

즉, 스프링의 구조는 결국 SRP 위에서 동작합니다.