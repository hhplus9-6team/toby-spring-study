# 2.3 개발자를 위한 테스팅 프레임워크 JUnit

> 스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.
>
> JUnit은 사실상 자바의 표준 테스팅 프레임워크로, 프레임워크 자체가 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일을 담당한다.
>
> 따라서 프레임워크에서 동작하는 코드는 main() 메소드도 필요 없고, 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

## 2.3.1 JUnit 테스트 실행 방법

JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit을 시작시켜 줘야 한다.

### main() 메소드를 이용한 실행

어디에든 main() 메소드를 하나 추가하고, 그 안에 `JUnitCore` 클래스의 main 메소드를 호출해주면 된다. 파라미터에는 `@Test` 테스트 메소드를 가진 클래스의 이름을 넣어준다.

```java
import org.junit.runner.JUnitCore;

public static void main(String[] args) {
    JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

### IDE를 이용한 실행

가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.

- main() 메소드를 만들지 않아도 된다
- 클래스, 패키지, 프로젝트 단위로 테스트를 일괄 실행할 수 있다
- 테스트의 진행 상황과 결과를 시각적으로 확인할 수 있다
- 테스트 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수를 확인할 수 있다

### 빌드 도구를 이용한 실행

ANT나 Maven 같은 빌드 도구에서 제공하는 JUnit 플러그인이나 태스크를 이용해 실행할 수도 있다. HTML이나 텍스트 파일의 형태로 테스트 결과를 만들어준다.

## 2.3.2 테스트 결과의 일관성

기존 테스트에는 문제가 있었다. 테스트를 여러 번 실행하면 이전에 등록한 데이터 때문에 기본키 중복 에러가 발생하여 테스트가 실패할 수 있었다.

테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다면 좋은 테스트라고 할 수 없다.

**코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.**

### deleteAll()의 추가

테스트 수행 전에 DB를 초기화하기 위해 `deleteAll()` 메소드를 UserDao에 추가한다.

```java
public void deleteAll() throws SQLException {
    Connection c = dataSource.getConnection();

    PreparedStatement ps = c.prepareStatement("DELETE FROM users");
    ps.executeUpdate();

    ps.close();
    c.close();
}
```

### getCount()의 추가

`deleteAll()`이 정상적으로 동작하는지 검증하기 위해 `getCount()` 메소드도 함께 추가한다.

```java
public int getCount() throws SQLException {
    Connection c = dataSource.getConnection();

    PreparedStatement ps = c.prepareStatement("SELECT COUNT(*) FROM users");

    ResultSet rs = ps.executeQuery();
    rs.next();
    int count = rs.getInt(1);

    rs.close();
    ps.close();
    c.close();

    return count;
}
```

### deleteAll()과 getCount()의 테스트

새로 추가한 기능을 기존 addAndGet() 테스트에 적용한다.

```java
@Test
public void addAndGet() throws SQLException {
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));

    User user = new User("leevigong", "리비공", "password1234");
    dao.add(user);
    assertThat(dao.getCount(), is(1));

    User user2 = dao.get(user.getId());
    assertThat(user2.getName(), is(user.getName()));
    assertThat(user2.getPassword(), is(user.getPassword()));
}
```

테스트 실행 전에 `deleteAll()`로 데이터를 초기화하고, `getCount()`로 검증하므로 **몇 번을 반복해도 동일한 결과**를 얻을 수 있다.

> 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다. DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

## 2.3.3 포괄적인 테스트

### getCount() 테스트

하나의 경우만 테스트하는 것은 부족하다. 성의 없이 테스트를 만들면 문제가 있는 코드인데도 테스트가 성공하게 만들어버릴 수 있다. `getCount()`에 대해 좀 더 꼼꼼하게, User를 하나씩 추가하며 카운트가 정확히 증가하는지 확인한다.

```java
@Test
public void count() throws SQLException {
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));

    dao.add(user1);
    assertThat(dao.getCount(), is(1));

    dao.add(user2);
    assertThat(dao.getCount(), is(2));

    dao.add(user3);
    assertThat(dao.getCount(), is(3));
}
```

> [!NOTE]
> JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다.

### addAndGet() 테스트 보완

`get()` 메소드에 대한 테스트도 보강한다. User를 하나만 등록하면 정말 그 User를 가져온 것인지 확인할 수 없으므로, 두 개의 User를 등록하고 각각 정확히 조회되는지 검증한다.

```java
@Test
public void addAndGet() throws SQLException {
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));

    User user1 = new User("id1", "name1", "pw1");
    User user2 = new User("id2", "name2", "pw2");

    dao.add(user1);
    dao.add(user2);
    assertThat(dao.getCount(), is(2));

    User userget1 = dao.get(user1.getId());
    assertThat(userget1.getName(), is(user1.getName()));
    assertThat(userget1.getPassword(), is(user1.getPassword()));

    User userget2 = dao.get(user2.getId());
    assertThat(userget2.getName(), is(user2.getName()));
    assertThat(userget2.getPassword(), is(user2.getPassword()));
}
```

### get() 예외조건에 대한 테스트

존재하지 않는 id로 `get()`을 호출하면 어떻게 될까? 이때 `EmptyResultDataAccessException`이 던져지도록 만들고, 이를 테스트로 검증한다.

```java
@Test(expected = EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException {
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));

    dao.get("unknown_id"); // 이 메소드 실행 중에 예외가 발생해야 한다
}
```

`@Test`의 `expected` 엘리먼트에 예외 클래스를 지정해두면, 해당 예외가 던져지면 테스트가 성공하고, 예외가 발생하지 않으면 테스트가 실패한다.

### get() 메소드의 수정

테스트를 성공시키려면 `get()` 메소드에서 조회 결과가 없을 때 예외를 던지도록 수정해야 한다.

```java
public User get(String id) throws SQLException {
    // ...
    ResultSet rs = ps.executeQuery();

    User user = null; // User를 null로 초기화
    if (rs.next()) {  // 쿼리 결과가 있으면 User 오브젝트를 만들어 값을 넣어준다
        user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
    }

    rs.close();
    ps.close();
    c.close();

    if (user == null) throw new EmptyResultDataAccessException(1);

    return user;
}
```

### 포괄적인 테스트의 중요성

개발자가 자주 하는 실수 중 하나는 성공하는 테스트만 골라서 만드는 것이다. 스프링의 창시자인 로드 존슨은 **"항상 네거티브 테스트를 먼저 만들라"** 고 조언했다. `get()` 메소드의 경우라면, 존재하는 id가 주어졌을 때 해당 레코드를 정확히 가져오는가를 테스트하는 것도 중요하지만, 존재하지 않는 id가 주어졌을 때는 어떻게 반응할지를 먼저 결정하고, 이를 테스트로 만들어서 검증해야 한다.

테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이면 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능하다.

## 2.3.4 테스트가 이끄는 개발

### 기능설계를 위한 테스트

`getUserFailure()` 테스트를 만들 때를 돌아보면, `get()` 메소드의 기능을 코드로 먼저 구현한 것이 아니라, 테스트를 먼저 만들고 그 테스트가 성공하도록 코드를 작성한 셈이다.

테스트할 조건, 행위, 결과를 먼저 결정한 것이다.

| | 내용 |
|:---:|------|
| **조건** | 가져올 사용자 정보가 존재하지 않는 경우에 |
| **행위** | 존재하지 않는 id로 get()을 실행하면 |
| **결과** | 특별한 예외가 던져진다 |

이런 식으로 보면 테스트 코드는 마치 잘 작성된 하나의 기능 정의서처럼 보인다.

### 테스트 주도 개발(TDD)

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 **테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법**을 **테스트 주도 개발(TDD, Test Driven Development)** 이라고 한다.

> "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"

이것이 TDD의 기본 원칙이다.

### TDD의 장점

- 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다
- 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다
- 오류를 빨리 발견할 수 있고, 빨리 발견된 오류는 쉽게 대응이 가능하다
- 자연스럽게 단위 테스트를 만들 수 있다
- 코드에 대한 피드백을 매우 빠르게 받을 수 있다

> TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 한 짧게 가져가도록 권장한다.

## 2.3.5 테스트 코드 개선

테스트 코드 자체가 중복되는 부분이 있다. 애플리케이션 컨텍스트를 만드는 부분과 UserDao를 가져오는 부분이 매 테스트 메소드마다 반복된다. 테스트 코드도 언제든지 내부 구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들어야 한다.

### @Before

JUnit이 제공하는 `@Before` 애노테이션을 이용하면, `@Test` 메소드가 실행되기 전에 먼저 실행되는 메소드를 정의할 수 있다.

```java
public class UserDaoTest {
    private UserDao dao;
    private User user1;
    private User user2;
    private User user3;

    @Before
    public void setUp() {
        ApplicationContext context =
            new GenericXmlApplicationContext("applicationContext.xml");
        this.dao = context.getBean("userDao", UserDao.class);

        this.user1 = new User("id1", "name1", "pw1");
        this.user2 = new User("id2", "name2", "pw2");
        this.user3 = new User("id3", "name3", "pw3");
    }

    @Test
    public void addAndGet() throws SQLException {
        dao.deleteAll();
        assertThat(dao.getCount(), is(0));

        dao.add(user1);
        dao.add(user2);
        assertThat(dao.getCount(), is(2));

        User userget1 = dao.get(user1.getId());
        assertThat(userget1.getName(), is(user1.getName()));
        assertThat(userget1.getPassword(), is(user1.getPassword()));

        User userget2 = dao.get(user2.getId());
        assertThat(userget2.getName(), is(user2.getName()));
        assertThat(userget2.getPassword(), is(user2.getPassword()));
    }

    @Test
    public void count() throws SQLException {
        dao.deleteAll();
        assertThat(dao.getCount(), is(0));

        dao.add(user1);
        assertThat(dao.getCount(), is(1));

        dao.add(user2);
        assertThat(dao.getCount(), is(2));

        dao.add(user3);
        assertThat(dao.getCount(), is(3));
    }

    @Test(expected = EmptyResultDataAccessException.class)
    public void getUserFailure() throws SQLException {
        dao.deleteAll();
        assertThat(dao.getCount(), is(0));

        dao.get("unknown_id");
    }
}
```

### JUnit이 테스트를 수행하는 방식

JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.

1. 테스트 클래스에서 `@Test`가 붙은 `public void`형이며 파라미터가 없는 테스트 메소드를 모두 찾는다
2. 테스트 클래스의 오브젝트를 **하나 만든다**
3. `@Before`가 붙은 메소드가 있으면 실행한다
4. `@Test`가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다
5. `@After`가 붙은 메소드가 있으면 실행한다
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다
7. 모든 테스트의 결과를 종합해서 돌려준다

> [!NOTE]
> **각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다.** 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 이는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 보장하기 위해서다.

### 픽스처(Fixture)

테스트를 수행하는 데 필요한 정보나 오브젝트를 **픽스처(fixture)** 라고 한다.

UserDaoTest에서는 `dao`가 대표적인 픽스처이고, `add()` 메소드에 전달하는 `User` 오브젝트들도 픽스처라고 볼 수 있다. 이런 픽스처들은 여러 테스트에서 반복적으로 사용되므로 `@Before` 메소드를 이용해 생성해두면 편리하다.


## 질문
- JUnit이 매 테스트 메소드마다 새로운 테스트 클래스 오브젝트를 생성하는 이유는 무엇인가?
- TDD의 기본 원칙은 무엇이며, TDD로 개발할 때의 장점은 무엇인가?
