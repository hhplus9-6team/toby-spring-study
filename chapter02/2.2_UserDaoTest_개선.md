# 2.2 UserDaoTest 개선

앞서 2.1에서 알아보았던 UserDaoTest 클래스의 두가지 문제점을 개선해보겠습니다.

- 수동 확인 작업이 필요
- 실행 작업의 번거로움

## 2.2.1 테스트 검증의 자동화

모든 테스트 코드는 아래와 같은 결과를 가질 수 있습니다.

```
테스트 실행
├─ 성공
└─ 실패
   ├─ 에러 발생 (예: 예외 던짐)
   └─ 기대한 결과와 다른 결과 (값 불일치)
```

수정 전의 UserDaoTest는 add()로 저장한 객체를 get()으로 조회하여 console에 조회 결과를 출력하여
개발자로 하여금 직접 값을 확인하는 방식으로 검증을 진행하였습니다.

```java
System.out.println(user.getName());
System.out.println(user.getPassword());
System.out.println(user.getName());
```

console로 직접 테스트 결과를 확인하는 코드는 if else 분기 처리를 적용하여 개선할 수 있습니다.

```java
if (!user.getName().equals(user2.getName())) {
    System.out.println("테스트 실패 (name)");
} else if (!user.getPassword().equals(user2.getPassword())) {
    System.out.println("테스트 실패 (password)");
} else {
    System.out.println("조회 테스트 성공");
}
```

위와 같이 간단한 수정만으로도 테스트 결과 검증을 자동화한 테스트 코드로 개선 할 수 있었습니다.
수정된 UserDaoTest는 사용자를 등록하고, 조회하는 두 가지 기능이 정상적으로 동작하는지 언제든지 손쉽게 확인할 수 있게 해줍니다.
다시 말해, 이 코드의 동작에 `영향을 미치는 수정사항`이 발생 할 경우 `테스트 코드를 실행`함으로써 기능 동작 여부를 간단하게 확인할 수 있습니다.

`"테스트랑 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"`

## 2.2.2 테스트의 효율적인 수행과 결과 관리

UserDaoTest는 테스트 실행을 위한 main() 메소드를 직접 구현하였습니다.
만약 애플리케이션의 규모가 커지고 테스트의 개수가 많아진다면 main() 메소드를 이용한 테스트를 수행하는 일이 점점 부담이 될 것입니다.

효율적인 테스트 수행을 위해서는

- 일정한 패턴을 가진 테스트를 만들 수 있다.
- 많은 테스트를 간단히 실행할 수 있다.
- 테스트 결과를 종합해서 볼 수 있다.
- 테스트가 실패한 곳을 빠르게 찾을 수 있다.

위와 같은 기능을 갖춘 테스트 도구가 필요합니다. `JUnit`은 Java로 단위 테스트를 만들 때 유용하게 사용할 수 있는 테스팅 프레임워크입니다.

### Junit 테스트로 전환

프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다.
테스팅 프레임워크인 JUnit 역시 테스트를 위한 오브젝트를 생성하고 실행하는 역할을 개발자 대신 수행합니다.

### 테스트 메소드 전환

JUnit 프레임워크는 아래와 같이 두 가지 조건을 테스트 메소드 작성 시 요구합니다.

- 메소드가 `public`으로 선언되어야한다.
- 메소드에 `@Test` 애노테이션을 붙여야한다.

```java
public class UserDaoTest {
 @Test
 public void addAndGet() throws new SQLException{
  ApplicationContext context = new .....

  ....

 }
}
```

### 검증 코드 전환

앞서 if else를 사용하여 개선하였던 테스트 결과 검증 부분을 JUnit이 제공하는 방법으로 전환해보겠습니다.

`if (!user.getName().equals(user2.getName()))` -> `assertThat(user2.getName(), is(user.getName))`

JUnit은 테스트 메소드 수행 시 예외가 발생하거나 asserThat() 검증에 실패하지 않고 메소드 수행이 완료되면 테스트가 성공했다고 인식합니다.

### JUnit 테스트 실행

JUnit 프레임워크를 이용해 앞에서 만든 테스트를 실행하는 코드를 만들어보겠습니다.

```java
public static void main(String[] args) {
 JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

이 클래스를 실행하면 테스트 수행 시간과 결과등을 콘솔에서 확인할 수 있습니다.

### 테스트 러너: main 없이 실행이 가능한 이유

일반적으로는 `main()`을 만들지 않고도 JUnit 테스트를 바로 실행할 수 있습니다. 이유는 다음과 같습니다.

- 테스트 탐색: IDE와 Gradle/Maven 테스트 플러그인은 클래스패스를 스캔해 `@Test`가 붙은 메서드를 자동으로 찾습니다.
- 실행 위임: 발견된 테스트는 JUnit 플랫폼(런처)이 인스턴스 생성, 라이프사이클 콜백(@BeforeEach/@AfterEach 등) 호출, 테스트 메서드 실행을 모두 담당합니다.
- 선택 실행: 런처는 클래스 또는 메서드 단위 선택 실행을 지원하므로, 콘솔 독립 실행이 필요할 때를 제외하면 `JUnitCore.main(...)` 진입점 없이도 원하는 테스트를 실행할 수 있습니다.

### 질문

1. 효율적인 테스트를 수행하기 위해서는 어떤 것들을 고려해야하나요?
2. 테스트 코드를 작성해야 하는 이유가 무엇이라고 생각하나요?
